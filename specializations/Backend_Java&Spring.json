{
  "profile": "Backend разработчик",
  "specialization": "Java / Spring",
  "competencies": [
    {
      "competency_name": "Навыки Java [CORE 90%]",
      "topics": [
        {
          "topic_name": "Коллекции и структуры данных",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какой интерфейс в Java используется для хранения уникальных элементов?",
              "var_1": "List реализует проверку уникальности через метод contains() при добавлении",
              "var_2": "Set использует внутренний механизм для предотвращения добавления дубликатов",
              "var_3": "Map обеспечивает уникальность ключей через внутреннюю хеш-таблицу",
              "var_4": "Collection предоставляет базовый контракт для работы с уникальными данными",
              "correct_answer": 2
            },
            {
              "level": "Middle",
              "question_text": "Когда следует использовать LinkedHashMap вместо HashMap?",
              "var_1": "Когда требуется автоматическая сортировка элементов по ключу",
              "var_2": "Когда необходимо сохранение порядка вставки элементов",
              "var_3": "Когда важна потокобезопасная работа с коллекцией",
              "var_4": "Когда нужна оптимизация операций поиска по значению",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Почему ConcurrentHashMap не поддерживает null в качестве ключа или значения?",
              "var_1": "Это связано с особенностями работы алгоритма сегментации данных",
              "var_2": "Невозможно различить отсутствие значения от явного null без дополнительной синхронизации",
              "var_3": "Оптимизация производительности требует исключения обработки null значений",
              "var_4": "Предотвращение race condition при проверке наличия элемента в коллекции",
              "correct_answer": 2
            }
          ]
        },
        {
          "topic_name": "Многопоточность и concurrency",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Что произойдёт при повторном вызове start() у объекта Thread?",
              "var_1": "Поток продолжит выполнение с текущей точки в методе run()",
              "var_2": "Будет выброшено исключение IllegalThreadStateException",
              "var_3": "Поток будет перезапущен с начала метода run()",
              "var_4": "JVM создаст новый экземпляр потока автоматически",
              "correct_answer": 2
            },
            {
              "level": "Middle",
              "question_text": "В чём основное преимущество ReentrantLock перед synchronized блоком?",
              "var_1": "ReentrantLock обеспечивает более высокую производительность при низкой конкуренции",
              "var_2": "ReentrantLock поддерживает tryLock() с таймаутом и прерывание ожидания",
              "var_3": "ReentrantLock автоматически освобождается при завершении метода",
              "var_4": "ReentrantLock предотвращает deadlock через встроенную детекцию",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Какую проблему решает happens-before отношение в Java Memory Model?",
              "var_1": "Гарантирует атомарность составных операций при работе с общими переменными",
              "var_2": "Обеспечивает видимость изменений между потоками через упорядочивание операций",
              "var_3": "Предотвращает создание лишних копий объектов в thread-local памяти",
              "var_4": "Оптимизирует переключение контекста между потоками через prefetching",
              "correct_answer": 2
            }
          ]
        },
        {
          "topic_name": "Stream API и функциональное программирование",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какой метод Stream API используется для преобразования элементов?",
              "var_1": "map() применяет функцию к каждому элементу",
              "var_2": "filter() отбирает элементы по предикату",
              "var_3": "flatMap() разворачивает вложенные потоки",
              "var_4": "reduce() комбинирует элементы в результат",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "В чём разница между map() и flatMap() в Stream API?",
              "var_1": "map() поддерживает параллельную обработку элементов автоматически",
              "var_2": "flatMap() объединяет несколько потоков в один плоский поток",
              "var_3": "map() кеширует промежуточные результаты для оптимизации",
              "var_4": "flatMap() применяет функцию только к непустым элементам",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Почему findAny() может быть эффективнее findFirst() на параллельных стримах?",
              "var_1": "findAny() использует специальную хеш-структуру для быстрого поиска элемента",
              "var_2": "findAny() не требует сохранения порядка, возвращая результат без координации потоков",
              "var_3": "findAny() применяет предварительную фильтрацию для уменьшения количества проверок",
              "var_4": "findAny() кеширует последние найденные элементы для повторного использования",
              "correct_answer": 2
            }
          ]
        }
      ]
    },
    {
      "competency_name": "Навыки Spring Framework [CORE 90%]",
      "topics": [
        {
          "topic_name": "Dependency Injection и IoC контейнер",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какая аннотация используется для автоматического внедрения зависимости?",
              "var_1": "@Autowired указывает Spring на место инъекции",
              "var_2": "@Inject работает аналогично для внедрения",
              "var_3": "@Resource связывает бин по имени ресурса",
              "var_4": "@Qualifier уточняет конкретный бин для внедрения",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "Когда следует использовать @Qualifier при внедрении зависимости?",
              "var_1": "Когда нужно отложить инициализацию бина до первого обращения",
              "var_2": "Когда в контексте несколько бинов одного типа",
              "var_3": "Когда требуется изменить scope бина динамически",
              "var_4": "Когда необходимо внедрить Optional зависимость",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Как Spring обрабатывает циклические зависимости при конструкторной инъекции?",
              "var_1": "Создаёт proxy объекты для разрыва цикла зависимостей",
              "var_2": "Не может разрешить и выбрасывает BeanCurrentlyInCreationException",
              "var_3": "Использует lazy initialization для одного из бинов",
              "var_4": "Переключается на field injection для проблемных бинов",
              "correct_answer": 2
            }
          ]
        },
        {
          "topic_name": "Spring Boot автоконфигурация",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какая аннотация включает механизм автоконфигурации в Spring Boot?",
              "var_1": "@SpringBootApplication комбинирует несколько аннотаций включая автоконфигурацию",
              "var_2": "@EnableAutoConfiguration активирует автоматическую настройку компонентов",
              "var_3": "@ComponentScan запускает сканирование и регистрацию бинов",
              "var_4": "@Configuration определяет класс как источник bean definitions",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "Как исключить конкретный класс автоконфигурации из загрузки?",
              "var_1": "Создать собственную конфигурацию с аналогичными бинами",
              "var_2": "Указать класс в параметре exclude аннотации @SpringBootApplication",
              "var_3": "Добавить свойство в application.properties для отключения",
              "var_4": "Использовать @ConditionalOnMissingBean в custom конфигурации",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Почему @ConditionalOnMissingBean может не сработать для пользовательского бина?",
              "var_1": "Пользовательские бины имеют приоритет @Primary по умолчанию",
              "var_2": "Условие проверяется только в рамках текущего application context",
              "var_3": "Condition кеширует результат при первой проверке",
              "var_4": "User configurations обрабатываются до auto-configurations",
              "correct_answer": 4
            }
          ]
        },
        {
          "topic_name": "Spring Data JPA",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какой интерфейс нужно расширить для создания JPA репозитория?",
              "var_1": "JpaRepository предоставляет методы для работы с сущностями",
              "var_2": "CrudRepository определяет базовые CRUD операции",
              "var_3": "PagingAndSortingRepository добавляет пагинацию к CRUD",
              "var_4": "Repository служит маркерным интерфейсом для репозиториев",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "В чём разница между getOne() и findById() в JPA репозитории?",
              "var_1": "getOne() загружает сущность немедленно с eager стратегией",
              "var_2": "getOne() возвращает ленивый прокси, findById() загружает сразу",
              "var_3": "findById() кеширует результат в первом уровне кеша",
              "var_4": "getOne() использует JPQL запрос, findById() Criteria API",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Какие проблемы создаёт FetchType.EAGER для связей @OneToMany?",
              "var_1": "JPA материализует все данные в память перед маппингом",
              "var_2": "Создаётся отдельная транзакция для каждой коллекции",
              "var_3": "Возникает N+1 проблема и декартово произведение при JOIN",
              "var_4": "Блокировка базы данных на время загрузки всех связей",
              "correct_answer": 3
            }
          ]
        }
      ]
    },
    {
      "competency_name": "Навыки проектирования REST API [CORE 85%]",
      "topics": [
        {
          "topic_name": "HTTP методы и статус-коды",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какой HTTP метод используется для создания нового ресурса?",
              "var_1": "POST отправляет данные для создания ресурса",
              "var_2": "PUT размещает ресурс по указанному URI",
              "var_3": "PATCH модифицирует часть существующего ресурса",
              "var_4": "GET получает представление ресурса с сервера",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "В чём разница между статус-кодами 401 и 403?",
              "var_1": "401 означает отсутствие credentials, 403 недостаточно прав",
              "var_2": "401 для публичных API, 403 для internal endpoints",
              "var_3": "401 временная блокировка, 403 постоянный запрет",
              "var_4": "401 требует retry, 403 кеширует ответ на клиенте",
              "correct_answer": 1
            },
            {
              "level": "Senior",
              "question_text": "Почему PUT должен быть идемпотентным согласно HTTP спецификации?",
              "var_1": "Идемпотентность требуется для корректной работы HTTP кеширования",
              "var_2": "Клиенты могут безопасно повторять запрос при сетевых сбоях",
              "var_3": "Прокси-серверы автоматически retry идемпотентные операции",
              "var_4": "Идемпотентность упрощает реализацию distributed transactions",
              "correct_answer": 2
            }
          ]
        },
        {
          "topic_name": "Версионирование API",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какой подход использует версию в URL пути типа /api/v1/users?",
              "var_1": "URI path versioning включает версию в путь запроса",
              "var_2": "Query parameter versioning передаёт версию как параметр",
              "var_3": "Header versioning использует custom HTTP заголовок",
              "var_4": "Media type versioning включает версию в Content-Type",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "Когда следует создавать новую мажорную версию API?",
              "var_1": "При оптимизации производительности существующих endpoints",
              "var_2": "При внесении breaking changes в контракт API",
              "var_3": "При добавлении новых опциональных полей в response",
              "var_4": "При изменении внутренней реализации без изменения интерфейса",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Как организовать deprecation process при выводе старой версии API?",
              "var_1": "Объявить deprecation с sunset date, добавить warning headers, поддержать transition period",
              "var_2": "Автоматически redirect запросы на новую версию с data transformation",
              "var_3": "Немедленно отключить старую версию, вернуть 410 Gone всем клиентам",
              "var_4": "Поддерживать старую версию неограниченно для backward compatibility",
              "correct_answer": 1
            }
          ]
        },
        {
          "topic_name": "Pagination и filtering",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какие параметры используются для offset-based пагинации?",
              "var_1": "page и size определяют номер страницы и количество элементов",
              "var_2": "offset и limit задают смещение и размер выборки",
              "var_3": "start и end указывают границы диапазона данных",
              "var_4": "cursor и count управляют позицией и количеством",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "В чём преимущество cursor-based pagination перед offset-based?",
              "var_1": "Cursor требует меньше памяти на сервере при обработке",
              "var_2": "Cursor избегает пропуска записей при изменении данных",
              "var_3": "Cursor позволяет прямой доступ к произвольной странице",
              "var_4": "Cursor обеспечивает параллельную загрузку нескольких страниц",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Какая проблема возникает при deep pagination с большими offset значениями?",
              "var_1": "Невозможность применить сортировку и фильтрацию одновременно",
              "var_2": "Необходимость хранения состояния пагинации для каждого клиента",
              "var_3": "Получение устаревших данных из-за кеширования результатов",
              "var_4": "База данных сканирует все пропускаемые строки, деградируя производительность",
              "correct_answer": 4
            }
          ]
        }
      ]
    },
    {
      "competency_name": "Навыки Apache Kafka [DAILY 70%]",
      "topics": [
        {
          "topic_name": "Основы Kafka и топики",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Что такое партиция в контексте Kafka топика?",
              "var_1": "Партиция это реплика данных для обеспечения fault tolerance",
              "var_2": "Партиция это упорядоченный лог сообщений внутри топика",
              "var_3": "Партиция это группа consumers для parallel processing",
              "var_4": "Партиция это временный buffer для incoming messages",
              "correct_answer": 2
            },
            {
              "level": "Middle",
              "question_text": "Как Kafka гарантирует порядок доставки сообщений?",
              "var_1": "Порядок гарантируется на уровне топика для всех партиций",
              "var_2": "Порядок обеспечивается timestamps на каждом сообщении",
              "var_3": "Порядок гарантируется внутри одной партиции",
              "var_4": "Порядок поддерживается consumer group coordinator",
              "correct_answer": 3
            },
            {
              "level": "Senior",
              "question_text": "Как ключ сообщения влияет на распределение по партициям?",
              "var_1": "Ключ используется только для логической группировки в топике",
              "var_2": "Kafka балансирует сообщения равномерно независимо от ключа",
              "var_3": "Ключ определяет приоритет обработки в consumer group",
              "var_4": "Сообщения с одним ключом попадают в одну партицию через хеширование",
              "correct_answer": 4
            }
          ]
        },
        {
          "topic_name": "Consumer groups и offset management",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Что представляет собой consumer group в Kafka?",
              "var_1": "Набор consumers, распределяющих партиции для чтения",
              "var_2": "Группа брокеров, обрабатывающих один топик",
              "var_3": "Коллекция топиков, объединённых по назначению",
              "var_4": "Механизм репликации между Kafka кластерами",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "В чём разница между auto-commit и manual commit offset?",
              "var_1": "Manual commit использует batch операции для эффективности",
              "var_2": "Auto-commit сохраняет периодически, manual даёт полный контроль",
              "var_3": "Auto-commit обеспечивает exactly-once, manual at-least-once",
              "var_4": "Auto-commit фиксирует после обработки, manual перед чтением",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Какая проблема возникает с auto-commit при длительной обработке сообщения?",
              "var_1": "Consumer coordinator теряет информацию о progress обработки",
              "var_2": "Увеличивается нагрузка на брокеры из-за частых commit операций",
              "var_3": "Другие consumers блокируются на время длительной обработки",
              "var_4": "Offset коммитится до завершения, сообщение теряется при сбое",
              "correct_answer": 4
            }
          ]
        },
        {
          "topic_name": "Producers и гарантии доставки",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какой параметр producer определяет подтверждение записи?",
              "var_1": "acks определяет количество реплик для acknowledgment",
              "var_2": "retries задаёт число попыток при сбое отправки",
              "var_3": "batch.size контролирует размер группы сообщений",
              "var_4": "linger.ms управляет задержкой перед отправкой",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "В чём разница между настройками acks=1 и acks=all в producer?",
              "var_1": "acks=1 обеспечивает лучшую throughput, acks=all exactly-once",
              "var_2": "acks=1 ждёт leader, acks=all требует всех in-sync реплик",
              "var_3": "acks=all использует sync отправку, acks=1 async очередь",
              "var_4": "acks=1 для критичных данных, acks=all для метрик",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Как idempotent producer предотвращает дублирование при retry?",
              "var_1": "Consumer автоматически дедуплицирует сообщения при чтении",
              "var_2": "Producer кеширует отправленные сообщения локально",
              "var_3": "Distributed lock механизм предотвращает параллельную отправку",
              "var_4": "Broker присваивает sequence number и фильтрует дубликаты",
              "correct_answer": 4
            }
          ]
        }
      ]
    },
    {
      "competency_name": "Алгоритмы и структуры данных [DAILY 65%]",
      "topics": [
        {
          "topic_name": "Сложность алгоритмов",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какая временная сложность поиска элемента в несортированном массиве?",
              "var_1": "O(n) требуется проверка каждого элемента в худшем случае",
              "var_2": "O(1) благодаря прямой адресации по индексу",
              "var_3": "O(log n) при использовании binary search алгоритма",
              "var_4": "O(n log n) из-за предварительной сортировки",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "Почему HashMap обеспечивает O(1) для операций get/put в среднем случае?",
              "var_1": "Последние элементы кешируются в быстрой памяти",
              "var_2": "Хеш-функция вычисляет позицию напрямую в массиве",
              "var_3": "Внутри используется balanced binary search tree",
              "var_4": "Элементы поддерживаются в отсортированном порядке",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Когда HashMap деградирует до O(n) и как Java 8 решает проблему?",
              "var_1": "При плохой хеш-функции, Java использует rehashing второго уровня",
              "var_2": "При concurrent доступе, Java применяет lock striping механизм",
              "var_3": "При коллизиях в bucket, Java 8 конвертирует list в red-black tree",
              "var_4": "При высоком load factor, Java автоматически увеличивает capacity",
              "correct_answer": 3
            }
          ]
        },
        {
          "topic_name": "Деревья и графы",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какое ключевое свойство определяет Binary Search Tree?",
              "var_1": "Каждый узел содержит максимум два дочерних элемента",
              "var_2": "Левое поддерево содержит меньшие значения, правое большие",
              "var_3": "Дерево автоматически балансируется при операциях вставки",
              "var_4": "Все листовые узлы находятся на одинаковой глубине",
              "correct_answer": 2
            },
            {
              "level": "Middle",
              "question_text": "В чём преимущество Red-Black дерева перед обычным BST?",
              "var_1": "Red-Black tree эффективно хранит дубликаты через цветовую маркировку",
              "var_2": "Red-Black tree гарантирует O(log n) через балансировку при изменениях",
              "var_3": "Red-Black tree использует меньше памяти благодаря компактной структуре",
              "var_4": "Red-Black tree поддерживает быструю сериализацию в binary формат",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Как работает алгоритм Дейкстры и какое у него ограничение?",
              "var_1": "Использует dynamic programming для вычисления всех путей параллельно",
              "var_2": "Применяет recursive traversal с memoization для оптимизации памяти",
              "var_3": "Выполняет breadth-first search с весами, работает на любых графах",
              "var_4": "Использует greedy approach с priority queue, не работает с отрицательными весами",
              "correct_answer": 4
            }
          ]
        },
        {
          "topic_name": "Сортировки и поиск",
          "questions": [
            {
              "level": "Junior",
              "question_text": "Какая сортировка гарантирует O(n log n) в среднем случае?",
              "var_1": "Merge Sort использует divide-and-conquer подход",
              "var_2": "Bubble Sort оптимальна для больших массивов",
              "var_3": "Selection Sort находит minimum на каждой итерации",
              "var_4": "Insertion Sort вставляет элементы в sorted часть",
              "correct_answer": 1
            },
            {
              "level": "Middle",
              "question_text": "Почему Quick Sort предпочтительнее Merge Sort на практике?",
              "var_1": "Quick Sort показывает стабильные результаты на любых данных",
              "var_2": "Quick Sort использует O(1) памяти и лучше работает с кешем",
              "var_3": "Quick Sort это stable sort в отличие от Merge Sort",
              "var_4": "Quick Sort легче распараллелить на multi-core системах",
              "correct_answer": 2
            },
            {
              "level": "Senior",
              "question_text": "Как выбор pivot элемента влияет на производительность Quick Sort?",
              "var_1": "Выбор максимального элемента минимизирует глубину рекурсии",
              "var_2": "Выбор среднего элемента гарантирует равномерное разбиение массива",
              "var_3": "Выбор первого элемента обеспечивает стабильную O(n log n) сложность",
              "var_4": "Выбор random или median-of-three снижает риск O(n²) на sorted данных",
              "correct_answer": 4
            }
          ]
        }
      ]
    }
  ]
}