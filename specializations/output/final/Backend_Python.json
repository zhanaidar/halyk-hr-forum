{
  "profile": "Backend разработчик",
  "specialization": "Python Backend",
  "file_name": "Backend_Python",
  "competencies": [
    {
      "competency": "Владение языком программирования Python",
      "type": "CORE",
      "importance": 90,
      "themes": [
        {
          "theme": "Структуры данных и алгоритмы в Python (списки, словари, множества, кортежи, генераторы)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая структура данных Python гарантирует уникальность элементов и используется для быстрой проверки наличия ID клиента банка?",
              "correct_answer": "Множество (set)",
              "var_1": "Кортеж (tuple)",
              "var_2": "Словарь (dict)",
              "var_3": "Список (list)",
              "var_4": "Множество (set)",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В системе обработки банковских транзакций нужно хранить 10 миллионов номеров счетов для быстрой проверки существования. Почему set предпочтительнее list?",
              "correct_answer": "Set обеспечивает O(1) проверку вхождения против O(n) у list",
              "var_1": "List занимает в три раза больше памяти при хранении чисел",
              "var_2": "Set использует индексацию по хешу с предварительной компиляцией структуры",
              "var_3": "Set автоматически сортирует данные для ускорения бинарного поиска",
              "var_4": "Set обеспечивает O(1) проверку вхождения против O(n) у list",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "При обработке 500 тысяч SMS-уведомлений телеком-оператора генератор вызывает memory leak в долгоживущем процессе. Какие архитектурные решения предотвратят это?",
              "correct_answer": "Батчинг с явным вызовом gc.collect(), ограничение через itertools.islice, переход на chunk-based processing",
              "var_1": "Батчинг с явным вызовом gc.collect(), ограничение через itertools.islice, переход на chunk-based processing",
              "var_2": "Настройка gc.set_threshold() с агрессивными значениями, замена генераторов на itertools.tee(), pooling соединений",
              "var_3": "Использование weakref.WeakValueDictionary для автоматической очистки, asyncio.Queue с maxsize, мемоизация результатов",
              "var_4": "Переход на list comprehension вместо генераторов, увеличение PYTHONMALLOC, применение sys.intern() для строк",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "ООП в Python: классы, наследование, полиморфизм, магические методы, декораторы",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой магический метод вызывается при создании строкового представления объекта класса Transaction для логирования в банковской системе?",
              "correct_answer": "__str__ или __repr__ для разных целей представления",
              "var_1": "__init__ для инициализации строкового представления объекта",
              "var_2": "__bytes__ или __unicode__ в зависимости от кодировки",
              "var_3": "__format__ для форматирования вывода в логи",
              "var_4": "__str__ или __repr__ для разных целей представления",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием @classmethod и @staticmethod при реализации фабричных методов для создания объектов Payment из разных источников (VISA, MasterCard, Halyk)?",
              "correct_answer": "@classmethod получает класс первым параметром, @staticmethod не получает автоматических параметров",
              "var_1": "@classmethod требует обязательный self параметр, @staticmethod получает cls автоматически",
              "var_2": "@classmethod получает класс первым параметром, @staticmethod не получает автоматических параметров",
              "var_3": "@staticmethod позволяет переопределение в наследниках, @classmethod создает singleton экземпляры",
              "var_4": "@staticmethod наследует метаклассы родителя, @classmethod работает только с текущим классом",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "Какие проблемы возникают при использовании множественного наследования для классов Account и Card в банковском API, и как правильно применить MRO для разрешения конфликтов методов authorize()?",
              "correct_answer": "Diamond problem и конфликты методов; использовать super() и контролировать порядок через C3 linearization",
              "var_1": "Проблемы производительности при вызове методов; использовать композицию вместо наследования с делегированием через __getattr__()",
              "var_2": "Diamond problem и конфликты методов; использовать super() и контролировать порядок через C3 linearization",
              "var_3": "Циклические импорты и дублирование кода; использовать множественное наследование через миксины с явным разрешением",
              "var_4": "Конфликты namespace и переопределение атрибутов; применять метаклассы для динамической сборки методов authorize()",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Асинхронное программирование: async/await, asyncio, корутины, event loop",
          "questions": [
            {
              "level": "Junior",
              "question": "Какое ключевое слово используется для определения асинхронной функции в Python?",
              "correct_answer": "async def",
              "var_1": "coroutine def",
              "var_2": "asyncio def",
              "var_3": "async def",
              "var_4": "await def",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В чем разница между await asyncio.sleep() и time.sleep() при обработке множественных запросов к API банковского сервиса?",
              "correct_answer": "asyncio.sleep освобождает event loop для других корутин, time.sleep блокирует поток",
              "var_1": "asyncio.sleep использует многопоточность, time.sleep работает в одном потоке",
              "var_2": "time.sleep обрабатывает запросы параллельно, asyncio.sleep выполняет последовательно",
              "var_3": "time.sleep освобождает GIL для других потоков, asyncio.sleep блокирует интерпретатор",
              "var_4": "asyncio.sleep освобождает event loop для других корутин, time.sleep блокирует поток",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "Какую стратегию выбрать для обработки 10000 одновременных WebSocket-соединений с клиентами банка: asyncio.gather() или asyncio.as_completed(), и почему?",
              "correct_answer": "asyncio.as_completed, позволяет обрабатывать результаты по мере готовности, снижая пиковую нагрузку на память",
              "var_1": "asyncio.as_completed, позволяет обрабатывать результаты по мере готовности, снижая пиковую нагрузку на память",
              "var_2": "asyncio.TaskGroup с ограничением semaphore, гарантирует контроль памяти и graceful shutdown",
              "var_3": "asyncio.gather, обеспечивает параллельную обработку всех соединений с максимальной производительностью",
              "var_4": "asyncio.wait с FIRST_COMPLETED, позволяет динамически масштабировать обработку входящих сообщений",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Оптимизация производительности Python-кода: профилирование, управление памятью, GIL, многопоточность vs многопроцессность",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой встроенный модуль Python используется для профилирования производительности кода?",
              "correct_answer": "cProfile или profile",
              "var_1": "performance или monitor",
              "var_2": "cProfile или profile",
              "var_3": "memory_profiler или tracemalloc",
              "var_4": "timeit или benchmark",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В банковском API обработка 10000 JSON-запросов занимает 45 секунд из-за GIL. Какой подход выбрать: многопоточность или многопроцессность?",
              "correct_answer": "Многопроцессность, так как парсинг JSON CPU-bound задача",
              "var_1": "Многопроцессность, так как парсинг JSON CPU-bound задача",
              "var_2": "Многопоточность с ThreadPoolExecutor для параллельной обработки JSON",
              "var_3": "Асинхронность через asyncio для ускорения парсинга данных",
              "var_4": "Многопоточность, GIL освобождается при операциях ввода-вывода",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В телеком-системе обработки платежей memory profiler показывает утечку памяти в循环е обработки транзакций. Циклические ссылки отсутствуют. Почему gc.collect() не решает проблему и как оптимизировать?",
              "correct_answer": "Объекты в старшем поколении GC редко проверяются, использовать gc.set_threshold или slots для классов",
              "var_1": "GIL блокирует освобождение памяти в многопоточном режиме, переключиться на asyncio с uvloop",
              "var_2": "Python держит объекты в кеше интернирования строк, использовать sys.intern(False) для очистки памяти",
              "var_3": "CPython использует reference counting с задержкой, вызывать gc.collect(generation=2) после каждой транзакции",
              "var_4": "Объекты в старшем поколении GC редко проверяются, использовать gc.set_threshold или slots для классов",
              "correct_position": 4
            }
          ]
        }
      ]
    },
    {
      "competency": "Понимание архитектуры БД (OLTP/OLAP оптимизации)",
      "type": "DAILY",
      "importance": 70,
      "themes": [
        {
          "theme": "Индексы и стратегии индексирования для OLTP-систем (B-tree, Hash, частичные индексы)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип индекса в PostgreSQL используется по умолчанию при создании индекса на колонку с данными о номерах счетов клиентов банка?",
              "correct_answer": "B-tree индекс",
              "var_1": "Hash индекс",
              "var_2": "B-tree индекс",
              "var_3": "BRIN индекс",
              "var_4": "GiST индекс",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В базе телеком-оператора таблица с 50 млн звонков содержит колонку status со значениями 'completed', 'failed', 'in_progress'. Нужен быстрый поиск активных звонков (2% от общего числа). Какой тип индекса оптимален?",
              "correct_answer": "Частичный индекс на WHERE status = 'in_progress'",
              "var_1": "B-tree индекс на колонку status",
              "var_2": "Составной индекс на (status, created_at)",
              "var_3": "Hash индекс на status для равенства",
              "var_4": "Частичный индекс на WHERE status = 'in_progress'",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "В OLTP-системе банка после добавления составного B-tree индекса (client_id, transaction_date, amount) запросы с фильтром только по amount стали медленными. Почему индекс не используется и как исправить?",
              "correct_answer": "Индекс не работает из-за левостороннего правила B-tree. Создать отдельный индекс на amount.",
              "var_1": "Статистика устарела после добавления индекса. Выполнить ANALYZE и обновить query planner statistics.",
              "var_2": "Индекс не работает из-за левостороннего правила B-tree. Создать отдельный индекс на amount.",
              "var_3": "Hash-индекс эффективнее для точных совпадений amount. Заменить B-tree на Hash индекс.",
              "var_4": "Индекс требует настройки fill factor. Пересоздать индекс с fill factor 70 для OLTP.",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Партиционирование таблиц и шардирование для масштабирования нагрузки",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип партиционирования в PostgreSQL использовать для таблицы транзакций банка по дате создания?",
              "correct_answer": "RANGE партиционирование по столбцу created_at",
              "var_1": "RANGE партиционирование по столбцу created_at",
              "var_2": "Вертикальное партиционирование по типу операции",
              "var_3": "LIST партиционирование по статусу транзакции",
              "var_4": "HASH партиционирование по столбцу transaction_id",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В банковском приложении таблица платежей выросла до 500 млн записей, запросы за последний месяц медленные. Партиционирование по месяцам есть, но не помогает. Что проверить в первую очередь?",
              "correct_answer": "Индексы на партициях и constraint_exclusion в настройках PostgreSQL",
              "var_1": "Индексы на партициях и constraint_exclusion в настройках PostgreSQL",
              "var_2": "Миграцию на горизонтальный шардинг по customer_id или region",
              "var_3": "Размер shared_buffers и количество worker_processes в PostgreSQL",
              "var_4": "Стратегию VACUUM и статистику автоанализатора таблиц",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Телеком оператор хранит CDR записи (100К записей/сек). После шардирования по customer_id аналитические отчеты по регионам стали выполняться 10+ минут с cross-shard запросами. Как исправить без переделки шардирования?",
              "correct_answer": "Внедрить отдельную OLAP базу с репликацией и партиционированием по region_id",
              "var_1": "Использовать federated таблицы с агрегирующими материализованными представлениями по регионам",
              "var_2": "Настроить distributed join optimization и query push-down в прокси-слое",
              "var_3": "Внедрить отдельную OLAP базу с репликацией и партиционированием по region_id",
              "var_4": "Добавить вторичные индексы по region_id с covering columns для аналитики",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Оптимизация запросов и анализ планов выполнения (EXPLAIN, ANALYZE)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая команда PostgreSQL показывает план выполнения запроса без его реального выполнения?",
              "correct_answer": "EXPLAIN",
              "var_1": "SHOW PLAN",
              "var_2": "DESCRIBE",
              "var_3": "EXPLAIN",
              "var_4": "ANALYZE",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В таблице транзакций банка 50 млн записей. Запрос с WHERE по client_id медленный. EXPLAIN показывает Seq Scan. Какое первое действие для оптимизации?",
              "correct_answer": "Создать индекс на поле client_id",
              "var_1": "Настроить материализованное представление для запроса",
              "var_2": "Создать индекс на поле client_id",
              "var_3": "Добавить партиционирование таблицы по client_id",
              "var_4": "Увеличить shared_buffers в конфигурации PostgreSQL",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "В OLTP системе процессинга платежей EXPLAIN ANALYZE показывает Index Scan с cost=1000, но actual time в 10 раз больше расчётного. Vacuum выполнен. Какая наиболее вероятная причина?",
              "correct_answer": "Устаревшая статистика таблицы, необходим ANALYZE",
              "var_1": "Фрагментация B-tree индекса на диске",
              "var_2": "Устаревшая статистика таблицы, необходим ANALYZE",
              "var_3": "Высокий fill factor индекса таблицы",
              "var_4": "Недостаточный shared_buffers для индекса",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Денормализация и материализованные представления для OLAP-аналитики",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое материализованное представление в PostgreSQL и чем оно отличается от обычного VIEW?",
              "correct_answer": "Материализованное представление физически хранит результат запроса на диске, требует обновления.",
              "var_1": "Материализованное представление физически хранит результат запроса на диске, требует обновления.",
              "var_2": "Виртуальная таблица, которая выполняет запрос каждый раз при обращении.",
              "var_3": "Кешированный результат запроса в оперативной памяти для быстрого доступа.",
              "var_4": "Индексированное представление с автоматическим обновлением при изменении базовых таблиц.",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В банковской системе нужно строить отчеты по транзакциям клиентов за месяц. Когда стоит денормализовать таблицы вместо использования материализованных представлений?",
              "correct_answer": "Когда данные редко меняются и нужна максимальная скорость чтения без задержек обновления.",
              "var_1": "Когда транзакции часто обновляются и важна консистентность данных между связанными таблицами.",
              "var_2": "Когда требуется автоматическое обновление данных при изменении источников в реальном времени.",
              "var_3": "Когда объем данных превышает память и нужна инкрементальная загрузка с партиционированием.",
              "var_4": "Когда данные редко меняются и нужна максимальная скорость чтения без задержек обновления.",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "В телеком-системе материализованное представление для аналитики CDR-записей обновляется 2 часа и блокирует запросы. Как решить проблему без простоя?",
              "correct_answer": "REFRESH MATERIALIZED VIEW CONCURRENTLY с уникальным индексом или переключение между двумя таблицами.",
              "var_1": "Партиционирование материализованного представления по датам с параллельным REFRESH каждой партиции",
              "var_2": "REFRESH MATERIALIZED VIEW CONCURRENTLY с уникальным индексом или переключение между двумя таблицами.",
              "var_3": "Использовать READ UNCOMMITTED изоляцию для запросов во время обновления представления",
              "var_4": "Перенести обновление на реплику с SNAPSHOT ISOLATION и переключить приложение через failover",
              "correct_position": 2
            }
          ]
        }
      ]
    },
    {
      "competency": "Опыт интеграции с ML-сервисами и поисковыми системами",
      "type": "DAILY",
      "importance": 60,
      "themes": [
        {
          "theme": "Интеграция с REST API ML-моделей: обработка запросов, батчинг, таймауты и retry-стратегии",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP-метод используется для отправки данных клиента в ML-сервис для скоринга кредитоспособности?",
              "correct_answer": "POST метод для передачи данных в теле запроса",
              "var_1": "GET метод с параметрами клиента в query string",
              "var_2": "POST метод для передачи данных в теле запроса",
              "var_3": "PUT метод для обновления данных скоринга в сервисе",
              "var_4": "PATCH метод для частичной передачи атрибутов клиента",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "Какую стратегию retry следует применить при интеграции с ML-сервисом определения мошеннических транзакций, если модель периодически перегружена?",
              "correct_answer": "Exponential backoff с jitter и ограничением максимального числа попыток",
              "var_1": "Linear backoff с увеличением таймаута на константу",
              "var_2": "Немедленный retry с фиксированной задержкой в 100 миллисекунд",
              "var_3": "Exponential backoff с jitter и ограничением максимального числа попыток",
              "var_4": "Circuit breaker с постоянным переключением на резервный сервис",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "В банковском приложении ML-сервис анализа документов обрабатывает запросы 2-5 секунд. Клиенты жалуются на таймауты при загрузке удостоверений личности. Как оптимизировать архитектуру интеграции?",
              "correct_answer": "Асинхронная обработка через очередь с webhook/polling для получения результата",
              "var_1": "Использовать HTTP/2 multiplexing для параллельной отправки нескольких документов",
              "var_2": "Асинхронная обработка через очередь с webhook/polling для получения результата",
              "var_3": "Кэширование результатов анализа документов в Redis на 24 часа",
              "var_4": "Увеличить таймаут соединения до 30 секунд с exponential backoff",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Работа с Elasticsearch: индексация данных, построение поисковых запросов и оптимизация производительности",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой метод Python Elasticsearch клиента используется для добавления документа в индекс?",
              "correct_answer": "Метод index() или create() для добавления документа",
              "var_1": "Метод insert() для вставки документа в индекс",
              "var_2": "Метод add_document() или put() для добавления записи",
              "var_3": "Метод index() или create() для добавления документа",
              "var_4": "Метод store() для сохранения документа в Elasticsearch",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В чем разница между keyword и text типами полей при индексации данных клиентов банка в Elasticsearch?",
              "correct_answer": "Keyword для точного поиска без анализа, text для полнотекстового поиска",
              "var_1": "Keyword для структурированных данных, text для неструктурированных JSON-полей",
              "var_2": "Keyword использует inverted index, text хранит данные без токенизации",
              "var_3": "Keyword для точного поиска без анализа, text для полнотекстового поиска",
              "var_4": "Text поддерживает агрегации и сортировку, keyword только для поиска",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "В банковском приложении поиск по транзакциям занимает 3-5 секунд при 50 млн документов. Какие первые шаги оптимизации производительности вы предпримете?",
              "correct_answer": "Проверить шардирование, добавить фильтры в filter context, оптимизировать mapping и использовать routing",
              "var_1": "Увеличить heap memory JVM, добавить replicas и настроить refresh_interval на минимум",
              "var_2": "Перейти на denormalized схему хранения, использовать nested types и увеличить количество нод",
              "var_3": "Проверить шардирование, добавить фильтры в filter context, оптимизировать mapping и использовать routing",
              "var_4": "Применить aggressive caching на уровне приложения, индексировать все поля и использовать wildcard queries",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Асинхронная обработка ML-инференса: очереди задач, кэширование результатов и мониторинг latency",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая библиотека Python используется для создания очередей задач при асинхронной обработке ML-инференса?",
              "correct_answer": "Celery с брокером Redis или RabbitMQ",
              "var_1": "Celery с брокером Redis или RabbitMQ",
              "var_2": "Flask-RQ с синхронным SQLite бэкендом",
              "var_3": "asyncio.Queue с встроенным TaskGroup менеджером",
              "var_4": "Threading.Queue с multiprocessing.Pool для параллелизма",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В банковском приложении нужно кэшировать результаты ML-классификации транзакций. Какую стратегию кэширования выбрать, если модель обновляется ежедневно?",
              "correct_answer": "TTL-кэш с временем жизни 24 часа и версионированием модели",
              "var_1": "TTL-кэш с временем жизни 24 часа и версионированием модели",
              "var_2": "Write-through кэш с немедленной записью в PostgreSQL и репликацией",
              "var_3": "LRU-кэш с вытеснением по размеру и инвалидацией по API",
              "var_4": "Персистентный Redis-кэш без TTL с ручной очисткой через cron",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В телеком-системе latency ML-инференса для fraud detection выросла с 200ms до 3s при нагрузке. Какие первые три метрики вы проверите для диагностики?",
              "correct_answer": "Размер очереди задач, memory usage модели, время сериализации/десериализации данных",
              "var_1": "Throughput API endpoint, disk I/O операций, версия ML-фреймворка",
              "var_2": "Количество запросов в секунду, температура GPU, load average системы",
              "var_3": "CPU утилизация сервера, bandwidth сети, количество активных соединений",
              "var_4": "Размер очереди задач, memory usage модели, время сериализации/десериализации данных",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Векторный поиск и embedding-модели: интеграция с vector databases (Pinecone, Milvus, pgvector) для семантического поиска",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой метод pgvector используется для создания индекса для векторного поиска по косинусной близости?",
              "correct_answer": "CREATE INDEX USING ivfflat с операторным классом vector_cosine_ops",
              "var_1": "CREATE INDEX USING ivfflat с операторным классом vector_cosine_ops",
              "var_2": "CREATE INDEX USING btree с операторным классом vector_l2_ops",
              "var_3": "CREATE INDEX USING hnsw с параметром similarity='cosine'",
              "var_4": "CREATE INDEX USING gin с операторным классом vector_ops для косинусного поиска",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В системе поиска банковских документов выбираете между Pinecone и pgvector. Какое решение предпочтительнее при требовании ACID-транзакций для синхронизации метаданных и векторов?",
              "correct_answer": "pgvector, так как обеспечивает транзакционную согласованность в PostgreSQL",
              "var_1": "pgvector, так как обеспечивает транзакционную согласованность в PostgreSQL",
              "var_2": "Milvus с использованием etcd для координации транзакций метаданных",
              "var_3": "Pinecone с дополнительным слоем Redis для обеспечения консистентности",
              "var_4": "Pinecone, так как поддерживает distributed transactions через API",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В продакшене телеком-оператора семантический поиск по обращениям клиентов показывает деградацию качества после 500K векторов в Milvus. Какие действия предпримете для оптимизации?",
              "correct_answer": "Настроить шардирование коллекции, оптимизировать nlist параметр IVF индекса, увеличить nprobe",
              "var_1": "Перейти на HNSW индекс, увеличить ef_construction и кэшировать эмбеддинги в Redis",
              "var_2": "Настроить шардирование коллекции, оптимизировать nlist параметр IVF индекса, увеличить nprobe",
              "var_3": "Мигрировать на Pinecone с serverless архитектурой для автоматического масштабирования базы",
              "var_4": "Применить dimensionality reduction через PCA до 128 измерений для ускорения поиска",
              "correct_position": 2
            }
          ]
        }
      ]
    },
    {
      "competency": "Проектирование REST API",
      "type": "CORE",
      "importance": 85,
      "themes": [
        {
          "theme": "Методы HTTP и принципы RESTful архитектуры",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP метод должен использоваться для получения списка банковских счетов клиента в REST API?",
              "correct_answer": "GET метод для безопасного чтения данных",
              "var_1": "POST метод для запроса данных клиента",
              "var_2": "PUT метод для извлечения списка счетов",
              "var_3": "GET метод для безопасного чтения данных",
              "var_4": "FETCH метод для получения ресурсов API",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием PUT и PATCH при обновлении данных клиента в банковской системе?",
              "correct_answer": "PUT заменяет весь ресурс, PATCH обновляет отдельные поля",
              "var_1": "PUT заменяет весь ресурс, PATCH обновляет отдельные поля",
              "var_2": "PUT требует аутентификацию токеном, PATCH работает через Basic Auth",
              "var_3": "PUT идемпотентен для банковских транзакций, PATCH создает новые записи",
              "var_4": "PUT используется для создания, PATCH для полного обновления ресурса",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Как спроектировать идемпотентность при обработке платежных транзакций через POST запросы в банковском API?",
              "correct_answer": "Использовать idempotency key в заголовках для дедупликации повторных запросов",
              "var_1": "Генерировать уникальный transaction_id на стороне сервера для каждого запроса",
              "var_2": "Использовать HTTP метод PUT вместо POST для автоматической идемпотентности",
              "var_3": "Использовать idempotency key в заголовках для дедупликации повторных запросов",
              "var_4": "Применять транзакционные блокировки базы данных с уровнем изоляции SERIALIZABLE",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Версионирование API и обратная совместимость",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP заголовок стандартно используется для указания версии API в REST запросах?",
              "correct_answer": "Accept с указанием application/vnd.company.v1+json или Custom-API-Version",
              "var_1": "Accept с указанием application/vnd.company.v1+json или Custom-API-Version",
              "var_2": "Content-Type с указанием application/json;version=1",
              "var_3": "Authorization с bearer token и версией API",
              "var_4": "X-Request-ID с префиксом номера версии API",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В банковском API необходимо изменить формат поля ИИН клиента с string на object. Какой подход версионирования минимизирует breaking changes для существующих клиентов?",
              "correct_answer": "Добавить новое поле iin_structured, сохранив старое iin deprecated",
              "var_1": "Добавить новое поле iin_structured, сохранив старое iin deprecated",
              "var_2": "Использовать версионирование через URL путь /api/v2 с новым форматом",
              "var_3": "Обновить поле iin с автоматическим преобразованием на стороне сервера",
              "var_4": "Применить Content Negotiation через заголовок Accept с версией схемы",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Телеком компания поддерживает 4 версии API для абонентов. Как спроектировать архитектуру для минимизации дублирования кода при сохранении независимости версий?",
              "correct_answer": "Единое доменное ядро, версионированные адаптеры на уровне presentation layer с трансформерами",
              "var_1": "Единое доменное ядро, версионированные адаптеры на уровне presentation layer с трансформерами",
              "var_2": "Отдельные микросервисы для каждой версии с общей базой данных и shared библиотеками",
              "var_3": "Feature flags для переключения логики версий с единой кодовой базой и runtime проверками",
              "var_4": "Монолитное приложение с версионированием через декораторы и conditional routing на уровне контроллеров",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Проектирование структуры ресурсов и эндпоинтов",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP метод используется для получения списка банковских транзакций клиента в REST API?",
              "correct_answer": "GET метод для безопасного получения данных",
              "var_1": "POST метод для запроса данных транзакций",
              "var_2": "FETCH метод для чтения банковских данных",
              "var_3": "PUT метод для извлечения списка операций",
              "var_4": "GET метод для безопасного получения данных",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "Как правильно структурировать эндпоинт для получения истории платежей конкретного клиента банка: /clients/{id}/payments или /payments?client_id={id}?",
              "correct_answer": "Вложенный ресурс /clients/{id}/payments показывает иерархию отношений",
              "var_1": "Query параметры обеспечивают лучшую производительность кэширования",
              "var_2": "REST требует использовать query параметры для фильтрации",
              "var_3": "Плоская структура /payments упрощает масштабирование API",
              "var_4": "Вложенный ресурс /clients/{id}/payments показывает иерархию отношений",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "Почему для API банковских переводов лучше использовать /transfers вместо PUT /accounts/{from}/balance и /accounts/{to}/balance при проектировании эндпоинтов?",
              "correct_answer": "Перевод - отдельная бизнес-операция требующая атомарности, аудита и идемпотентности",
              "var_1": "Раздельные эндпоинты обеспечивают лучшую гранулярность контроля доступа к счетам",
              "var_2": "REST требует ресурсо-ориентированного подхода через прямое изменение свойств объектов",
              "var_3": "PUT метод семантически корректнее описывает изменение состояния баланса счёта",
              "var_4": "Перевод - отдельная бизнес-операция требующая атомарности, аудита и идемпотентности",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Обработка ошибок, статус-коды и стандарты документирования API",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP статус-код должен возвращать REST API при успешном создании нового клиента банка?",
              "correct_answer": "201 Created",
              "var_1": "201 Created",
              "var_2": "204 No Content",
              "var_3": "202 Accepted",
              "var_4": "200 OK",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием статус-кодов 401 и 403 при проверке доступа к API платежных операций?",
              "correct_answer": "401 - не аутентифицирован, 403 - аутентифицирован но нет прав",
              "var_1": "401 - ошибка сервера аутентификации, 403 - неверные учетные данные",
              "var_2": "401 - истек токен доступа, 403 - пользователь не найден в системе",
              "var_3": "401 - не аутентифицирован, 403 - аутентифицирован но нет прав",
              "var_4": "401 - временная блокировка доступа, 403 - постоянный бан пользователя",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Как спроектировать централизованную обработку ошибок в REST API банковской системы для соблюдения PCI DSS и предотвращения утечки конфиденциальной информации в responses?",
              "correct_answer": "Middleware с маппингом исключений, логирование в защищенное хранилище, стандартизированные ошибки без деталей реализации",
              "var_1": "Try-except блоки в каждом endpoint с детальными traceback в JSON для отладки клиентами",
              "var_2": "Decorator-based обработка с передачей внутренних exception messages и database errors в response body",
              "var_3": "Middleware с маппингом исключений, логирование в защищенное хранилище, стандартизированные ошибки без деталей реализации",
              "var_4": "Global error handler с возвратом полных stack traces и SQL queries для прозрачности отладки",
              "correct_position": 3
            }
          ]
        }
      ]
    }
  ]
}