{
  "profile": "Backend разработчик",
  "specialization": "Golang Backend",
  "file_name": "Backend_Golang",
  "competencies": [
    {
      "competency": "Навыки работы с Golang",
      "type": "CORE",
      "importance": 90,
      "themes": [
        {
          "theme": "Concurrency и goroutines: channels, sync-пакет, race conditions, контекст выполнения",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая функция из пакета sync используется для ожидания завершения нескольких goroutines перед продолжением выполнения программы?",
              "correct_answer": "sync.WaitGroup с методами Add, Done и Wait",
              "var_1": "sync.Cond с методами Wait, Signal и Broadcast",
              "var_2": "sync.Mutex с методами Lock, Unlock и TryLock",
              "var_3": "sync.WaitGroup с методами Add, Done и Wait",
              "var_4": "sync.Once с методом Do для однократного выполнения",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В микросервисе обработки платежей банка нужно отменить все дочерние операции при таймауте основного запроса. Какой механизм context использовать и почему?",
              "correct_answer": "context.WithTimeout — автоматически отменяет операции по истечении времени",
              "var_1": "context.WithCancel — позволяет вручную отменить операции при необходимости",
              "var_2": "context.Background — создаёт корневой контекст для дочерних операций",
              "var_3": "context.WithDeadline — устанавливает точное время завершения всех операций",
              "var_4": "context.WithTimeout — автоматически отменяет операции по истечении времени",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "При масштабировании сервиса транзакций телеком-оператора с 10K до 100K RPS обнаружили деградацию из-за contention на sync.Mutex в кэше сессий. Как оптимизировать архитектуру?",
              "correct_answer": "Использовать sync.Map или шардированный кэш с множеством мьютексов",
              "var_1": "Использовать sync.Map или шардированный кэш с множеством мьютексов",
              "var_2": "Применить RWMutex с приоритетом на read-операции в кэше",
              "var_3": "Увеличить размер буфера каналов и использовать buffered channels",
              "var_4": "Перейти на atomic операции для всех полей структуры сессии",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Работа с интерфейсами, структурами и методами: композиция, встраивание, type assertions",
          "questions": [
            {
              "level": "Junior",
              "question": "Как правильно встроить структуру Account в структуру BankCustomer для получения доступа к её полям и методам?",
              "correct_answer": "Указать имя типа без имени поля: type BankCustomer struct { Account }",
              "var_1": "Объявить поле с тегом embed: type BankCustomer struct { Account `embed:\"true\"` }",
              "var_2": "Использовать указатель на тип: type BankCustomer struct { *Account Account }",
              "var_3": "Наследовать через интерфейс: type BankCustomer struct { implements Account }",
              "var_4": "Указать имя типа без имени поля: type BankCustomer struct { Account }",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В микросервисе платежей используется интерфейс PaymentProcessor с методом Process(). Нужно добавить валидацию для карточных платежей, сохранив существующую логику. Какой подход композиции лучше применить?",
              "correct_answer": "Создать структуру-обёртку с полем типа PaymentProcessor, реализующую дополнительную логику перед вызовом",
              "var_1": "Создать структуру-обёртку с полем типа PaymentProcessor, реализующую дополнительную логику перед вызовом",
              "var_2": "Встроить интерфейс PaymentProcessor в структуру карточного платежа через anonymous field",
              "var_3": "Модифицировать существующий интерфейс PaymentProcessor, добавив метод Validate() для карточных платежей",
              "var_4": "Использовать type assertion для проверки типа и добавления валидации в Process()",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В системе обработки транзакций банка интерфейс interface{} приходит из очереди. Почему type assertion к конкретному типу без проверки второго возвращаемого значения может вызвать критическую проблему в production?",
              "correct_answer": "Вызовет panic при несовпадении типа, что приведёт к падению сервиса обработки транзакций",
              "var_1": "Вызовет panic при несовпадении типа, что приведёт к падению сервиса обработки транзакций",
              "var_2": "Создаст memory leak из-за неосвобождённых ссылок на интерфейсный тип в очереди",
              "var_3": "Вернёт нулевое значение типа, что приведёт к некорректной обработке транзакции в базе",
              "var_4": "Произойдёт автоматическое приведение к базовому типу с потерей данных в полях структуры",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Управление памятью и производительность: garbage collector, профилирование, оптимизация аллокаций",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой инструмент стандартной библиотеки Go используется для профилирования использования памяти приложением?",
              "correct_answer": "pprof из пакета net/http/pprof или runtime/pprof",
              "var_1": "go tool trace и пакет runtime/trace",
              "var_2": "memstats из пакета runtime/debug с Trace()",
              "var_3": "pprof из пакета net/http/pprof или runtime/pprof",
              "var_4": "benchstat утилита с флагом -memprofile",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В высоконагруженном банковском API обработки платежей наблюдаются частые паузы GC. Какие параметры GOGC стоит настроить и почему?",
              "correct_answer": "Увеличить GOGC выше 100 для уменьшения частоты сборок мусора за счет большего потребления памяти",
              "var_1": "Увеличить GOGC выше 100 для уменьшения частоты сборок мусора за счет большего потребления памяти",
              "var_2": "Уменьшить GOGC ниже 100 для более агрессивной сборки мусора и снижения потребления памяти процессом",
              "var_3": "Настроить GOGC на динамическое значение через runtime.SetGCPercent в зависимости от текущей нагрузки системы",
              "var_4": "Установить GOGC=off для полного отключения автоматического сборщика мусора в критичных секциях кода",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В микросервисе обработки транзакций телеком-оператора профилирование показало 80% аллокаций на создание временных []byte при парсинге JSON. Как оптимизировать без изменения API?",
              "correct_answer": "Использовать sync.Pool для переиспользования буферов и jsoniter с предаллоцированными структурами",
              "var_1": "Использовать sync.Pool для переиспользования буферов и jsoniter с предаллоцированными структурами",
              "var_2": "Переключить encoding/json на easyjson с кодогенерацией для всех структур",
              "var_3": "Применить strings.Builder с предвыделенной capacity для JSON-строк",
              "var_4": "Увеличить GOGC до 200 и использовать runtime.SetFinalizer для буферов",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Обработка ошибок и panic recovery: error wrapping, custom errors, defer, best practices",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая функция из пакета fmt используется для создания ошибки с форматированным сообщением в Go?",
              "correct_answer": "fmt.Errorf",
              "var_1": "errors.Format",
              "var_2": "fmt.Error",
              "var_3": "errors.New",
              "var_4": "fmt.Errorf",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В банковском микросервисе обработки платежей нужно сохранить стек ошибок при передаче между слоями. Какой подход из стандартной библиотеки Go 1.13+ обеспечит это без внешних зависимостей?",
              "correct_answer": "fmt.Errorf с %w для wrapping и errors.Unwrap",
              "var_1": "fmt.Errorf с %w для wrapping и errors.Unwrap",
              "var_2": "errors.New с defer стеком для каждого слоя",
              "var_3": "panic с recover и log.Printf для трейсинга",
              "var_4": "error.Error() с конкатенацией строк через fmt.Sprintf",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В высоконагруженном процессинге транзакций телеком-оператора goroutine падает с panic в defer. Почему recover() в внешнем defer не перехватит этот panic и как правильно спроектировать многоуровневую защиту?",
              "correct_answer": "Panic в defer создает новый panic, прерывая цепочку. Нужен recover в каждом defer или wrapper-функция с отдельным defer-recover.",
              "var_1": "Panic в defer создает новый panic, прерывая цепочку. Нужен recover в каждом defer или wrapper-функция с отдельным defer-recover.",
              "var_2": "Defer выполняется LIFO, поэтому внешний recover срабатывает первым. Решение - использовать runtime.Goexit() вместо panic в defer.",
              "var_3": "Panic в defer попадает в runtime panic handler. Правильно использовать errgroup.WithContext для централизованной обработки ошибок goroutine.",
              "var_4": "Recover перехватывает все panic в стеке defer. Проблема в goroutine isolation - нужен общий context.Context с cancel propagation.",
              "correct_position": 1
            }
          ]
        }
      ]
    },
    {
      "competency": "Concurrency (горутины, каналы, синхронизация)",
      "type": "CORE",
      "importance": 85,
      "themes": [
        {
          "theme": "Goroutines: жизненный цикл, планировщик (scheduler), runtime и управление ресурсами",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой синтаксис используется для запуска новой горутины в Go?",
              "correct_answer": "Ключевое слово go перед вызовом функции",
              "var_1": "Ключевое слово go перед вызовом функции",
              "var_2": "Функция goroutine.Start() из пакета runtime",
              "var_3": "Ключевое слово async перед функцией",
              "var_4": "Метод runtime.NewGoroutine() для создания потока",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В банковском сервисе обработки платежей запускается 10000 горутин одновременно. Как ограничить их количество для контроля потребления памяти?",
              "correct_answer": "Использовать worker pool с буферизованным каналом или семафор",
              "var_1": "Установить GOMAXPROCS в runtime для ограничения параллелизма",
              "var_2": "Использовать worker pool с буферизованным каналом или семафор",
              "var_3": "Применить context.WithCancel для отмены лишних горутин",
              "var_4": "Использовать sync.WaitGroup с счетчиком максимальных горутин",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "Телеком-оператор обрабатывает 500k запросов/сек. Наблюдается высокая задержка GC и частые preemption горутин. Какие параметры runtime оптимизировать и почему?",
              "correct_answer": "GOMAXPROCS для CPU, GOGC для частоты GC, использовать sync.Pool для переиспользования объектов",
              "var_1": "GOMAXPROCS для CPU, GOGC для частоты GC, использовать sync.Pool для переиспользования объектов",
              "var_2": "Настроить GOTRACEBACK для профилирования, использовать buffered channels для снижения preemption",
              "var_3": "Установить runtime.LockOSThread() для критичных горутин, увеличить stack size через GOSTACK",
              "var_4": "Увеличить GOMAXPROCS до количества горутин, снизить GODEBUG для трейсинга планировщика",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Channels: типы каналов, буферизация, паттерны использования и deadlock prevention",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой синтаксис используется для создания буферизованного канала в Go с емкостью 10 элементов?",
              "correct_answer": "ch := make(chan int, 10)",
              "var_1": "ch := make(chan int, 10)",
              "var_2": "ch := make(chan int[10])",
              "var_3": "ch := make(chan int, buffer: 10)",
              "var_4": "ch := make(chan(10) int)",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В системе обработки банковских транзакций нужно распределить 1000 запросов между 5 воркерами. Какой размер буфера канала оптимален для предотвращения блокировки отправителя при кратковременных задержках воркеров?",
              "correct_answer": "Буфер размером 50-200, равный числу запросов на воркера",
              "var_1": "Буфер размером 1000, равный общему числу запросов",
              "var_2": "Буфер размером 5, равный количеству воркеров",
              "var_3": "Буфер размером 50-200, равный числу запросов на воркера",
              "var_4": "Небуферизованный канал для гарантированной синхронной обработки",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "В микросервисе обработки платежей телеком-оператора возникает deadlock при использовании двух каналов для координации между горутинами сбора метрик и отправки в Kafka. Какие три архитектурных паттерна предотвратят эту проблему?",
              "correct_answer": "Select с default, timeout context, разделение на однонаправленные каналы",
              "var_1": "Mutex для синхронизации доступа, atomic операции, worker pool pattern",
              "var_2": "Buffered каналы с большим размером, sync.WaitGroup, закрытие каналов defer",
              "var_3": "Использование sync.Once, semaphore pattern, каналы с capacity равным GOMAXPROCS",
              "var_4": "Select с default, timeout context, разделение на однонаправленные каналы",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Синхронизация: sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Once и их применение",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой примитив синхронизации используется для ожидания завершения нескольких горутин перед продолжением выполнения программы?",
              "correct_answer": "sync.WaitGroup с методами Add, Done и Wait",
              "var_1": "sync.WaitGroup с методами Add, Done и Wait",
              "var_2": "sync.Once для однократного выполнения после всех горутин",
              "var_3": "sync.Mutex с блокировкой до завершения горутин",
              "var_4": "context.Context с методами WithCancel и Done",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В системе обработки банковских транзакций необходимо кешировать курсы валют. Чтений в 100 раз больше записей. Какой примитив синхронизации оптимален и почему?",
              "correct_answer": "sync.RWMutex, позволяет множественные одновременные чтения при блокировке записи",
              "var_1": "atomic.Value, гарантирует атомарное чтение без блокировок для производительности",
              "var_2": "sync.RWMutex, позволяет множественные одновременные чтения при блокировке записи",
              "var_3": "sync.Mutex, обеспечивает потокобезопасность доступа к кешу валют",
              "var_4": "sync.Map, оптимизирована для высоконагруженных сценариев с частыми чтениями",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "При инициализации подключения к платежному шлюзу используется sync.Once, но после сетевой ошибки переподключение не происходит. Как архитектурно решить проблему повторной инициализации при сохранении потокобезопасности?",
              "correct_answer": "Использовать sync.Mutex с атомарной проверкой состояния или паттерн circuit breaker",
              "var_1": "Использовать sync.Mutex с атомарной проверкой состояния или паттерн circuit breaker",
              "var_2": "Использовать sync.Once с defer для автоматического сброса состояния",
              "var_3": "Применить sync.RWMutex с отложенной инициализацией через sync.Pool",
              "var_4": "Вызывать sync.Once.Reset() перед повторной инициализацией подключения",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Продвинутые паттерны конкурентности: worker pools, context cancellation, select statement и race conditions",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой оператор в Go позволяет горутине ожидать данные из нескольких каналов одновременно?",
              "correct_answer": "Оператор select",
              "var_1": "Функция multiplex",
              "var_2": "Оператор select",
              "var_3": "Оператор switch",
              "var_4": "Метод WaitGroup",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В банковской системе обработки платежей нужно остановить все воркеры при завершении работы. Какой механизм Context использовать для graceful shutdown?",
              "correct_answer": "context.WithCancel с вызовом cancel() и ожидание через sync.WaitGroup",
              "var_1": "context.WithDeadline и закрытие каналов через defer close()",
              "var_2": "context.WithCancel с вызовом cancel() и ожидание через sync.WaitGroup",
              "var_3": "context.Background с сигналами из os.Signal и channel broadcast",
              "var_4": "context.WithTimeout с достаточно большим значением таймаута",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "В телеком-биллинге worker pool обрабатывает 10000 транзакций/сек, но появились race conditions при обновлении счетчиков. Как оптимально решить без деградации производительности?",
              "correct_answer": "Использовать atomic операции для счетчиков или sharding с отдельными каналами",
              "var_1": "Использовать atomic операции для счетчиков или sharding с отдельными каналами",
              "var_2": "Использовать buffered каналы большой емкости для сериализации доступа",
              "var_3": "Применить sync.RWMutex с приоритетом на чтение для счетчиков",
              "var_4": "Обернуть все операции со счетчиками в глобальный sync.Mutex",
              "correct_position": 1
            }
          ]
        }
      ]
    },
    {
      "competency": "Event-Driven Architecture",
      "type": "DAILY",
      "importance": 70,
      "themes": [
        {
          "theme": "Message Brokers и паттерны обмена сообщениями (RabbitMQ, Kafka, NATS)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой паттерн обмена сообщениями в RabbitMQ используется для отправки одного сообщения нескольким подписчикам одновременно?",
              "correct_answer": "Fanout exchange или паттерн Publish-Subscribe",
              "var_1": "Topic exchange с wildcard маршрутизацией",
              "var_2": "Direct exchange с routing key",
              "var_3": "Point-to-Point queue с round-robin",
              "var_4": "Fanout exchange или паттерн Publish-Subscribe",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В банковской системе нужно обрабатывать транзакции клиентов с гарантией порядка для каждого клиента. Kafka или RabbitMQ и какой механизм использовать?",
              "correct_answer": "Kafka сpartitioning по clientID для сохранения порядка внутри partition",
              "var_1": "RabbitMQ с priority queue для упорядочивания транзакций по timestamp",
              "var_2": "NATS JetStream с consumer groups и acknowledgment для каждого сообщения",
              "var_3": "Kafka с single partition для глобальной последовательности всех операций",
              "var_4": "Kafka сpartitioning по clientID для сохранения порядка внутри partition",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "В телеком-системе после деплоя consumers начали массово отваливаться с ошибками timeout при чтении из Kafka. Продюсеры работают нормально. Какие три основные причины проверить?",
              "correct_answer": "Размер batch fetch, session.timeout и медленная обработка сообщений блокирующая poll",
              "var_1": "Недостаточная пропускная способность сети, ошибки DNS резолвинга и перегрузка брокера",
              "var_2": "Версия клиентской библиотеки Kafka, конфликты offset commit и неправильный consumer group ID",
              "var_3": "Количество партиций, replication factor и настройки компрессии сообщений в продюсере",
              "var_4": "Размер batch fetch, session.timeout и медленная обработка сообщений блокирующая poll",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Event Sourcing и CQRS паттерны в Golang приложениях",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое Event Sourcing и как он отличается от традиционного хранения состояния в базе данных?",
              "correct_answer": "Хранение всех изменений как последовательности событий, а не текущего состояния.",
              "var_1": "Хранение всех изменений как последовательности событий, а не текущего состояния.",
              "var_2": "Асинхронная обработка событий через message broker для снижения нагрузки на БД.",
              "var_3": "Репликация данных между микросервисами через события для согласованности состояний.",
              "var_4": "Кэширование текущего состояния в памяти для быстрого доступа к данным.",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В банковском приложении на Golang нужно реализовать историю транзакций клиента. Когда стоит использовать CQRS вместо обычного CRUD подхода?",
              "correct_answer": "Когда требования к чтению и записи различаются, нужна масштабируемость чтения.",
              "var_1": "Когда требования к чтению и записи различаются, нужна масштабируемость чтения.",
              "var_2": "Когда микросервисная архитектура требует синхронизации данных между сервисами через API.",
              "var_3": "Когда база данных перегружена и требуется кэширование запросов к данным.",
              "var_4": "Когда нужна поддержка транзакций с ACID гарантиями для финансовых операций.",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "В телеком-системе обработки платежей на Golang с Event Sourcing возникла проблема: восстановление агрегата из 50000 событий занимает 3 секунды. Как оптимизировать производительность?",
              "correct_answer": "Внедрить снапшоты агрегата каждые N событий, восстанавливать от последнего снапшота.",
              "var_1": "Внедрить снапшоты агрегата каждые N событий, восстанавливать от последнего снапшота.",
              "var_2": "Применить параллельную обработку событий через горутины с sync.WaitGroup для ускорения.",
              "var_3": "Использовать материализованные представления в PostgreSQL для хранения текущего состояния агрегата.",
              "var_4": "Кэшировать события в Redis, восстанавливать агрегат из кэша при запросе.",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Обработка ошибок и retry механизмы в асинхронных системах",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой Go-пакет используется для реализации экспоненциальной задержки между retry попытками при обработке сообщений из Kafka?",
              "correct_answer": "time.Sleep с увеличивающимся интервалом или backoff библиотека",
              "var_1": "time.Sleep с увеличивающимся интервалом или backoff библиотека",
              "var_2": "kafka.RetryPolicy с встроенным exponential backoff механизмом",
              "var_3": "sync.WaitGroup с экспоненциальным счетчиком попыток",
              "var_4": "context.WithTimeout с увеличивающимся deadline для retry",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В event-driven системе банка сообщение обработки платежа падает с temporary error. Когда использовать Dead Letter Queue вместо бесконечных retry?",
              "correct_answer": "После исчерпания лимита retry попыток или при превышении TTL сообщения",
              "var_1": "При детектировании poison message через валидацию schema сообщения перед обработкой",
              "var_2": "После исчерпания лимита retry попыток или при превышении TTL сообщения",
              "var_3": "После получения HTTP 5xx статуса от downstream сервиса обработки транзакций",
              "var_4": "При первой же ошибке для сохранения идемпотентности операций платежей",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "В телеком системе обработки биллинга events теряются при перезапуске сервиса. Consumer offset коммитится после обработки, но есть дубликаты при retry. Как спроектировать идемпотентность?",
              "correct_answer": "Использовать idempotency key в базе с уникальным индексом и транзакционный outbox pattern",
              "var_1": "Применить exactly-once semantics через Kafka transactions с isolation.level=read_committed для consumer group",
              "var_2": "Коммитить offset перед обработкой события и использовать distributed lock на время обработки",
              "var_3": "Хранить offset в Redis с TTL и проверять существование записи перед обработкой",
              "var_4": "Использовать idempotency key в базе с уникальным индексом и транзакционный outbox pattern",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Saga паттерн и распределенные транзакции в микросервисной архитектуре",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое Saga паттерн в микросервисной архитектуре?",
              "correct_answer": "Последовательность локальных транзакций с компенсирующими действиями при ошибках",
              "var_1": "Последовательность локальных транзакций с компенсирующими действиями при ошибках",
              "var_2": "Глобальная транзакция объединяющая операции нескольких микросервисов в одну",
              "var_3": "Механизм синхронной репликации данных между связанными микросервисами",
              "var_4": "Распределенная транзакция с двухфазным коммитом через координатор",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "Какой тип Saga использовать для процесса открытия банковского счета с проверкой в 5 сервисах: choreography или orchestration?",
              "correct_answer": "Orchestration, так как требуется централизованный контроль сложного бизнес-процесса",
              "var_1": "Choreography, так как сервисы банка работают автономно",
              "var_2": "Orchestration, так как требуется централизованный контроль сложного бизнес-процесса",
              "var_3": "Hybrid подход с choreography для параллельных проверок",
              "var_4": "Choreography для лучшей масштабируемости и отказоустойчивости системы",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "В телеком-системе Saga зависла на 3-м шаге из 7. Компенсирующие транзакции отработали частично. Как диагностировать и восстановить консистентность?",
              "correct_answer": "Проверить состояние в saga state store, откатить частичные компенсации, повторно запустить компенсации идемпотентно",
              "var_1": "Запустить manual rollback скрипт для всех шагов, очистить saga instance из базы, инициировать новую сагу",
              "var_2": "Использовать distributed lock для блокировки саги, перезапустить с первого шага через orchestrator с увеличенным timeout",
              "var_3": "Проверить состояние в saga state store, откатить частичные компенсации, повторно запустить компенсации идемпотентно",
              "var_4": "Откатить всю транзакцию через two-phase commit протокол, записать failure event в message broker для повторной обработки",
              "correct_position": 3
            }
          ]
        }
      ]
    },
    {
      "competency": "Проектирование REST/gRPC API",
      "type": "CORE",
      "importance": 85,
      "themes": [
        {
          "theme": "Принципы REST API: HTTP методы, коды ответов, versioning и resource naming",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP метод следует использовать для получения списка банковских счетов клиента в REST API?",
              "correct_answer": "GET метод для безопасного чтения данных",
              "var_1": "FETCH метод для чтения коллекций данных",
              "var_2": "GET метод для безопасного чтения данных",
              "var_3": "POST метод для безопасной передачи данных",
              "var_4": "PUT метод для получения ресурсов клиента",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "Какой код ответа вернуть, когда клиент банка пытается перевести деньги со счета с недостаточным балансом?",
              "correct_answer": "422 Unprocessable Entity с описанием бизнес-ошибки",
              "var_1": "422 Unprocessable Entity с описанием бизнес-ошибки",
              "var_2": "402 Payment Required для недостаточности средств",
              "var_3": "403 Forbidden с указанием причины отказа",
              "var_4": "400 Bad Request с детализацией ошибки баланса",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Как спроектировать versioning REST API для банковского мобильного приложения, чтобы обеспечить обратную совместимость при изменении структуры данных платежей?",
              "correct_answer": "URL versioning с семантическим версионированием и поддержкой минимум двух версий одновременно",
              "var_1": "Content negotiation через Accept header с JSON Schema validation для каждой версии",
              "var_2": "GraphQL federation с schema stitching для поддержки legacy endpoints платежных сервисов",
              "var_3": "URL versioning с семантическим версионированием и поддержкой минимум двух версий одновременно",
              "var_4": "Header-based versioning с deprecation notices и автоматической миграцией данных клиента",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Проектирование gRPC сервисов: Protocol Buffers, streaming, error handling и interceptors",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип данных в Protocol Buffers используется для передачи денежных сумм в тенге с точностью до тиын?",
              "correct_answer": "double или создать custom message с int64 для тиын",
              "var_1": "string с форматированием через decimal для финансовых операций",
              "var_2": "double или создать custom message с int64 для тиын",
              "var_3": "int32 для хранения целых тенге и дробной части",
              "var_4": "float для представления суммы в тенге с копейками",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "Какой тип streaming в gRPC выбрать для реализации real-time уведомлений о транзакциях клиента банка: unary, server streaming или bidirectional streaming?",
              "correct_answer": "Server streaming для отправки последовательности уведомлений клиенту",
              "var_1": "Bidirectional streaming для двустороннего обмена уведомлениями с клиентом",
              "var_2": "Server streaming для отправки последовательности уведомлений клиенту",
              "var_3": "Client streaming для агрегации транзакций перед отправкой уведомлений",
              "var_4": "Unary RPC для каждого уведомления с polling механизмом",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "Как спроектировать interceptor для логирования чувствительных данных ИИН и номера карты в gRPC сервисе банка с учетом требований ПДн?",
              "correct_answer": "Unary/stream interceptor с маскированием через reflection proto-полей, помеченных custom option sensitive",
              "var_1": "Unary/stream interceptor с маскированием через reflection proto-полей, помеченных custom option sensitive",
              "var_2": "Middleware с regex-паттернами для поиска ИИН/карт в JSON payload запросов",
              "var_3": "Stream interceptor с шифрованием AES-256 чувствительных полей перед записью в логи",
              "var_4": "Unary interceptor с whitelist разрешенных полей и полным логированием остальных данных",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Архитектура API: идемпотентность, pagination, filtering, rate limiting и authentication",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое идемпотентность REST API и какие HTTP методы являются идемпотентными?",
              "correct_answer": "Повторный запрос даёт тот же результат. GET, PUT, DELETE идемпотентны.",
              "var_1": "Повторный запрос возвращает статус 304. PUT, PATCH, DELETE идемпотентны.",
              "var_2": "Запрос выполняется один раз. POST, GET, PATCH являются идемпотентными.",
              "var_3": "Кэширование результата запроса. GET, POST, OPTIONS считаются идемпотентными.",
              "var_4": "Повторный запрос даёт тот же результат. GET, PUT, DELETE идемпотентны.",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "Какой подход pagination выбрать для API выписок по счетам клиента банка: offset-based или cursor-based, и почему?",
              "correct_answer": "Cursor-based, чтобы избежать пропусков транзакций при добавлении новых записей.",
              "var_1": "Cursor-based, чтобы избежать пропусков транзакций при добавлении новых записей.",
              "var_2": "Offset-based, так как он проще в реализации и понятнее клиентам API.",
              "var_3": "Cursor-based с кешированием результатов для повышения производительности запросов базы данных.",
              "var_4": "Offset-based с сортировкой по дате транзакции и индексом на таблице.",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Как спроектировать идемпотентность для POST запроса создания платежа в банковском API, учитывая сетевые таймауты и retry логику клиентов?",
              "correct_answer": "Idempotency-Key в заголовке, хранение ключа с результатом в Redis/БД, проверка дубликатов.",
              "var_1": "Transaction ID в query параметрах, дедупликация через UNIQUE INDEX и обработка constraint violation.",
              "var_2": "Distributed lock через etcd на время обработки, release после завершения транзакции платежа.",
              "var_3": "UUID в теле запроса, валидация на уникальность через PRIMARY KEY constraint в PostgreSQL.",
              "var_4": "Idempotency-Key в заголовке, хранение ключа с результатом в Redis/БД, проверка дубликатов.",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Оптимизация и масштабирование: connection pooling, batch operations, caching strategies и load balancing",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое connection pooling в контексте работы с базой данных PostgreSQL в Golang?",
              "correct_answer": "Переиспользование установленных соединений с БД вместо создания новых для каждого запроса.",
              "var_1": "Группировка нескольких запросов в одну транзакцию для повышения производительности базы данных.",
              "var_2": "Переиспользование установленных соединений с БД вместо создания новых для каждого запроса.",
              "var_3": "Кэширование результатов SQL-запросов в памяти для уменьшения нагрузки на БД.",
              "var_4": "Автоматическое распределение запросов между несколькими репликами PostgreSQL для балансировки нагрузки.",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В банковской системе с пиковой нагрузкой 5000 RPS какую стратегию кеширования выбрать для справочника курсов валют, обновляемого раз в минуту?",
              "correct_answer": "Cache-aside с TTL 60 секунд и preemptive refresh за 5 секунд до истечения.",
              "var_1": "Read-through с TTL 5 минут и lazy loading при cache miss для минимизации latency.",
              "var_2": "Cache-aside с TTL 60 секунд и preemptive refresh за 5 секунд до истечения.",
              "var_3": "Distributed cache с eventual consistency и TTL 30 секунд через Redis Cluster replication.",
              "var_4": "Write-through кеш с синхронным обновлением при каждом изменении в источнике данных.",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "Как спроектировать batch operations для gRPC API массовых платежей в телеком-биллинге, чтобы избежать head-of-line blocking при частичных сбоях?",
              "correct_answer": "Использовать server-side streaming с независимой обработкой каждой операции и partial success response с детализацией ошибок.",
              "var_1": "Применить client-side streaming с buffering операций в памяти и синхронным commit после получения всех запросов.",
              "var_2": "Реализовать bidirectional streaming с circuit breaker на уровне соединения и автоматическим retry всего батча.",
              "var_3": "Использовать unary RPC с транзакционной обработкой всего батча и rollback при первой ошибке платежа.",
              "var_4": "Использовать server-side streaming с независимой обработкой каждой операции и partial success response с детализацией ошибок.",
              "correct_position": 4
            }
          ]
        }
      ]
    },
    {
      "competency": "Тестирование и работа с legacy кодом",
      "type": "DAILY",
      "importance": 65,
      "themes": [
        {
          "theme": "Написание unit и integration тестов для Golang приложений с использованием testify и gomock",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой метод testify/assert используется для проверки, что функция вернула ошибку nil?",
              "correct_answer": "assert.NoError или require.NoError",
              "var_1": "assert.Nil или require.Nil",
              "var_2": "assert.NoError или require.NoError",
              "var_3": "assert.ErrorIs с nil",
              "var_4": "assert.Empty для error",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием testify/assert и testify/require при тестировании критичных операций с базой данных банковских транзакций?",
              "correct_answer": "require немедленно прерывает тест при ошибке, предотвращая некорректные данные",
              "var_1": "assert логирует ошибки транзакций в отдельный файл для аудита",
              "var_2": "assert продолжает выполнение теста для проверки целостности всех данных",
              "var_3": "require выполняет автоматический rollback при обнаружении ошибки транзакции",
              "var_4": "require немедленно прерывает тест при ошибке, предотвращая некорректные данные",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "Вы добавляете unit-тесты в legacy код обработки платежей, где 10 функций напрямую вызывают database/sql. Какой подход минимизирует рефакторинг для внедрения gomock?",
              "correct_answer": "Создать интерфейс поверх существующих SQL-вызовов и использовать adapter pattern",
              "var_1": "Использовать monkey patching для подмены database/sql в тестах",
              "var_2": "Переписать функции с использованием gomock.Controller для SQL драйвера",
              "var_3": "Заменить database/sql на sqlmock во всех функциях напрямую",
              "var_4": "Создать интерфейс поверх существующих SQL-вызовов и использовать adapter pattern",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Рефакторинг legacy кода: работа с технических долгом и стратегии постепенной модернизации",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое технический долг в контексте legacy кода?",
              "correct_answer": "Накопленные проблемы кода, требующие рефакторинга для поддержки и развития.",
              "var_1": "Финансовые затраты на поддержку устаревших версий библиотек и фреймворков.",
              "var_2": "Документация устаревшего кода, требующая обновления перед новыми фичами.",
              "var_3": "Накопленные проблемы кода, требующие рефакторинга для поддержки и развития.",
              "var_4": "Метрики покрытия тестами, показывающие процент непротестированного legacy функционала.",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "Какую стратегию выбрать для рефакторинга монолитного банковского сервиса на Go с высоким покрытием тестами: Big Bang Rewrite или Strangler Fig Pattern?",
              "correct_answer": "Strangler Fig Pattern для постепенной миграции без остановки критичных операций.",
              "var_1": "Blue-Green Deployment с полной заменой монолита за один релиз.",
              "var_2": "Big Bang Rewrite для быстрой миграции на современную архитектуру.",
              "var_3": "Feature Toggle Pattern для пошагового отключения старого функционала монолита.",
              "var_4": "Strangler Fig Pattern для постепенной миграции без остановки критичных операций.",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "В legacy платежном сервисе телеком-оператора обнаружены race conditions при миграции на новую архитектуру. Как безопасно выявить и устранить проблему в продакшене?",
              "correct_answer": "Включить race detector в staging, добавить sync.Mutex, использовать feature flags для постепенного роллаута.",
              "var_1": "Включить race detector в staging, добавить sync.Mutex, использовать feature flags для постепенного роллаута.",
              "var_2": "Добавить distributed locks через Redis, применить eventual consistency и откатиться к синхронной обработке.",
              "var_3": "Использовать goroutine pool с буферизованными каналами, увеличить GOMAXPROCS и мониторить через pprof.",
              "var_4": "Запустить race detector в проде с уменьшенным трафиком, заменить глобальные переменные на context.Value.",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Покрытие legacy кода тестами: техники характеризационного тестирования и работа с зависимостями",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое характеризационное тестирование (characterization testing) при работе с legacy кодом?",
              "correct_answer": "Тесты, документирующие текущее поведение системы без изменения кода.",
              "var_1": "Процесс анализа кодовой базы для выявления технического долга.",
              "var_2": "Тесты, проверяющие корректность рефакторинга legacy системы перед деплоем.",
              "var_3": "Тесты производительности для измерения характеристик устаревшего кода.",
              "var_4": "Тесты, документирующие текущее поведение системы без изменения кода.",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В legacy системе банка метод ProcessPayment() зависит от внешнего API платежного шлюза. Какой паттерн использовать для изоляции этой зависимости при написании тестов?",
              "correct_answer": "Dependency Injection с использованием интерфейсов для мокирования шлюза.",
              "var_1": "Factory Method для создания экземпляров клиента внешнего API.",
              "var_2": "Adapter паттерн для оборачивания HTTP-клиента платежного шлюза.",
              "var_3": "Dependency Injection с использованием интерфейсов для мокирования шлюза.",
              "var_4": "Singleton паттерн для централизованного управления соединениями с API.",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "В legacy монолите телеком оператора метод CalculateBilling() содержит 800 строк с прямыми обращениями к БД, файловой системе и глобальным переменным. Опишите пошаговую стратегию покрытия его тестами без рефакторинга логики.",
              "correct_answer": "Обернуть в Facade, извлечь зависимости через Seam-точки, написать интеграционные тесты с testcontainers, затем постепенно изолировать внешние вызовы.",
              "var_1": "Использовать monkey patching через библиотеку bouk/monkey для подмены глобальных функций, покрыть весь метод одним snapshot-тестом.",
              "var_2": "Применить Golden File тестирование для всех сценариев, замокировать БД через sqlmock, использовать vfsgen для файловой системы.",
              "var_3": "Обернуть в Facade, извлечь зависимости через Seam-точки, написать интеграционные тесты с testcontainers, затем постепенно изолировать внешние вызовы.",
              "var_4": "Создать моки для всех зависимостей через gomock, написать юнит-тесты с полной изоляцией, затем рефакторить внутреннюю логику.",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Использование table-driven tests и benchmark тестов для оптимизации производительности legacy систем",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая структура данных используется для определения тестовых случаев в table-driven тестах в Go?",
              "correct_answer": "Слайс структур с полями input и expected",
              "var_1": "Структура с вложенными подструктурами для каждого теста",
              "var_2": "Карта с ключами-строками и значениями interface{}",
              "var_3": "Слайс структур с полями input и expected",
              "var_4": "Массив интерфейсов с методами Run и Validate",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В legacy системе обработки платежей банка некоторые тесты падают с разными результатами при параллельном запуске через t.Parallel(). Какая наиболее вероятная причина?",
              "correct_answer": "Разделяемое состояние между тестами или race condition в коде",
              "var_1": "Разделяемое состояние между тестами или race condition в коде",
              "var_2": "Недостаточная изоляция окружения через testcontainers или Docker",
              "var_3": "Использование t.Cleanup вместо defer для очистки ресурсов",
              "var_4": "Порядок выполнения тестов влияет на результаты бенчмарков",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "При оптимизации legacy модуля тарификации телеком-оператора бенчмарк показывает 15000 B/op с 250 аллокациями. Какие два первых шага для диагностики проблемы?",
              "correct_answer": "Запустить pprof с alloc_space и проверить escape analysis компилятора",
              "var_1": "Увеличить GOMAXPROCS и включить race detector для выявления утечек",
              "var_2": "Запустить pprof с alloc_space и проверить escape analysis компилятора",
              "var_3": "Добавить sync.Pool для переиспользования объектов и включить trace",
              "var_4": "Запустить benchmem с cpu profiling и проверить garbage collector метрики",
              "correct_position": 2
            }
          ]
        }
      ]
    }
  ]
}