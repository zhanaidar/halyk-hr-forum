{
  "profile": "QA Engineer",
  "specialization": "QA Manual / Functional",
  "file_name": "QA_Manual",
  "competencies": [
    {
      "competency": "Навык написания тест-кейсов",
      "type": "CORE",
      "importance": 90,
      "themes": [
        {
          "theme": "Структура и обязательные элементы тест-кейса",
          "questions": [
            {
              "level": "Junior",
              "question": "Какие три обязательных элемента должен содержать любой тест-кейс?",
              "correct_answer": "Предусловия, шаги выполнения и ожидаемый результат",
              "var_1": "Описание функции, категория и статус выполнения",
              "var_2": "ID тест-кейса, версия продукта и тестовые данные",
              "var_3": "Название, приоритет, автор и дата создания",
              "var_4": "Предусловия, шаги выполнения и ожидаемый результат",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В чем разница между шагами тест-кейса для API интеграции с платежным шлюзом банка и UI-теста той же функции?",
              "correct_answer": "API шаги содержат технические параметры запроса, UI описывает действия пользователя",
              "var_1": "API тесты проверяют backend, UI тесты фокусируются на frontend",
              "var_2": "API шаги содержат SQL-запросы, UI описывает HTTP-методы запросов",
              "var_3": "API шаги содержат технические параметры запроса, UI описывает действия пользователя",
              "var_4": "UI шаги включают валидацию ответа, API описывает визуальные элементы",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Как оптимизировать структуру тест-кейсов для регресса мобильного банкинга с 50+ бизнес-флоу, чтобы минимизировать дублирование и поддержку?",
              "correct_answer": "Применить модульную структуру с переиспользуемыми preconditions и shared steps",
              "var_1": "Создать отдельные тест-кейсы для каждого флоу с полным описанием",
              "var_2": "Применить модульную структуру с переиспользуемыми preconditions и shared steps",
              "var_3": "Использовать Page Object Model для структурирования тестовой документации",
              "var_4": "Группировать тест-кейсы по приоритету и покрывать критичные сценарии",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Техники тест-дизайна при написании тест-кейсов",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая техника тест-дизайна используется для проверки граничных значений поля ввода суммы перевода от 1 до 1000000 тенге?",
              "correct_answer": "Boundary Value Analysis (анализ граничных значений)",
              "var_1": "Equivalence Partitioning (разбиение на классы эквивалентности)",
              "var_2": "Boundary Value Analysis (анализ граничных значений)",
              "var_3": "Decision Table Testing (тестирование таблиц решений)",
              "var_4": "Pairwise Testing (попарное тестирование параметров)",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В чем разница между применением Pairwise Testing и All Combinations при тестировании формы регистрации корпоративного клиента банка с 8 полями по 3 значения каждое?",
              "correct_answer": "Pairwise покрывает все пары значений, сокращая количество тест-кейсов с 6561 до ~20",
              "var_1": "All Combinations покрывает критические пары, Pairwise генерирует полное покрытие всех 6561 комбинаций",
              "var_2": "Pairwise использует ортогональные массивы для сокращения с 6561 до 81 тест-кейса минимум",
              "var_3": "Pairwise покрывает все пары значений, сокращая количество тест-кейсов с 6561 до ~20",
              "var_4": "Pairwise тестирует граничные значения, All Combinations проверяет все возможные комбинации полностью",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Как оптимизировать набор тест-кейсов для мобильного банкинга с 15 модулями, используя Risk-Based Testing, при ограниченном времени регресса перед релизом?",
              "correct_answer": "Приоритизировать критичные платежные операции и авторизацию, применить Pairwise для некритичных модулей, использовать smoke-suite",
              "var_1": "Приоритизировать критичные платежные операции и авторизацию, применить Pairwise для некритичных модулей, использовать smoke-suite",
              "var_2": "Создать полную трассировку требований, провести exploratory testing всех модулей, задокументировать все найденные дефекты в Jira",
              "var_3": "Применить Boundary Value Analysis ко всем полям, использовать Decision Table для бизнес-логики каждого модуля отдельно",
              "var_4": "Провести полное тестирование всех 15 модулей методом Exhaustive Testing, покрыв все возможные комбинации входных данных",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Приоритизация и организация тест-кейсов в тест-сьютах",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое тест-сьют в контексте тестирования мобильного банкинга?",
              "correct_answer": "Набор логически сгруппированных тест-кейсов для выполнения.",
              "var_1": "Отчет о найденных дефектах в системе.",
              "var_2": "Документ с требованиями к тестированию приложения.",
              "var_3": "Инструмент для автоматического запуска всех тестов.",
              "var_4": "Набор логически сгруппированных тест-кейсов для выполнения.",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "По каким критериям следует приоритизировать тест-кейсы для регрессионного тестирования платежной системы банка при ограниченном времени?",
              "correct_answer": "Критичность бизнес-функций, частота использования, история дефектов, риски.",
              "var_1": "Скорость выполнения теста, размер данных, количество проверок, наличие документации.",
              "var_2": "Критичность бизнес-функций, частота использования, история дефектов, риски.",
              "var_3": "Сложность тест-кейсов, время выполнения, алфавитный порядок, покрытие кода.",
              "var_4": "Дата создания тестов, количество шагов, автоматизируемость, приоритет разработчика.",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "Как спроектировать структуру тест-сьютов для тестирования системы дистанционного банковского обслуживания с учетом требований НБРК к регуляторным проверкам и частых релизов?",
              "correct_answer": "Разделить на regulatory compliance suite, smoke/sanity, функциональные модули, интеграционные, с тегированием по приоритетам и возможностью быстрой выборки критичных проверок.",
              "var_1": "Организовать по функциональным модулям приложения с полным регрессом перед каждым релизом и отдельной папкой для документации НБРК.",
              "var_2": "Создать единый сьют с приоритетами P0-P3, где регуляторные требования включены в функциональные тесты модулей с метками compliance.",
              "var_3": "Структурировать по ролям пользователей и бизнес-процессам с выделением критичных транзакций, добавив чек-лист для аудиторов регулятора.",
              "var_4": "Разделить на regulatory compliance suite, smoke/sanity, функциональные модули, интеграционные, с тегированием по приоритетам и возможностью быстрой выборки критичных проверок.",
              "correct_position": 4
            }
          ]
        },
        {
          "theme": "Поддержка и актуализация тест-кейсов в процессе разработки",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой статус нужно присвоить тест-кейсу после изменения требований к функционалу мобильного приложения банка?",
              "correct_answer": "Статус 'Требует обновления' или 'Draft' до актуализации шагов",
              "var_1": "Статус 'Passed' с комментарием о необходимости пересмотра",
              "var_2": "Статус 'Deprecated' с архивацией предыдущей версии тест-кейса",
              "var_3": "Статус 'Требует обновления' или 'Draft' до актуализации шагов",
              "var_4": "Статус 'Blocked' до получения финальной версии требований",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "Как определить приоритет актуализации тест-кейсов при изменении API интеграции с платежным шлюзом: обновить сначала smoke-тесты или регрессионные?",
              "correct_answer": "Сначала smoke-тесты критичных платежных сценариев, затем регрессионные",
              "var_1": "Обновить end-to-end тесты интеграции, затем unit-тесты API",
              "var_2": "Параллельно обновить все тесты согласно приоритету дефектов",
              "var_3": "Сначала smoke-тесты критичных платежных сценариев, затем регрессионные",
              "var_4": "Сначала регрессионные тесты, затем smoke-тесты платежей",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Команда выпускает релизы каждые 2 недели, 60% тест-кейсов устаревают после спринта. Какую архитектуру поддержки тест-кейсов внедрить для телеком-продукта с частыми изменениями тарифов?",
              "correct_answer": "Модульная структура с переиспользуемыми компонентами, версионирование по релизам, автоматизированная трассировка требований",
              "var_1": "BDD-фреймворк с Gherkin-сценариями, привязка к пользовательским историям через Jira",
              "var_2": "Централизованное хранилище с полным регрессом, обновление всех кейсов после каждого спринта",
              "var_3": "Модульная структура с переиспользуемыми компонентами, версионирование по релизам, автоматизированная трассировка требований",
              "var_4": "Документирование в Confluence с чек-листами, разделение по функциональным доменам продукта",
              "correct_position": 3
            }
          ]
        }
      ]
    },
    {
      "competency": "Навык кроссплатформенного тестирования",
      "type": "CORE",
      "importance": 80,
      "themes": [
        {
          "theme": "Основы кроссплатформенного тестирования: различия в поведении веб-приложений в браузерах (Chrome, Firefox, Safari, Edge)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой инструмент браузера позволяет эмулировать различные user-agent для тестирования кроссбраузерной совместимости веб-приложения банка?",
              "correct_answer": "Developer Tools (DevTools) во вкладке Network Conditions или Device Mode",
              "var_1": "Extensions Manager с установленным плагином User-Agent Switcher для тестирования",
              "var_2": "Browser Compatibility Checker в настройках браузера под вкладкой Testing",
              "var_3": "Developer Tools (DevTools) во вкладке Network Conditions или Device Mode",
              "var_4": "Application Settings в разделе Browser Emulation и Platform Configuration",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "При тестировании личного кабинета банка вы обнаружили, что в Safari датапикер не открывается, а в Chrome работает корректно. В чем наиболее вероятная причина различия?",
              "correct_answer": "Safari не поддерживает нативный input type date или есть конфликт JavaScript событий",
              "var_1": "Различие в реализации Shadow DOM между браузерами конфликтует с компонентом",
              "var_2": "Safari использует webkit-префиксы для стилизации календаря, что блокирует открытие",
              "var_3": "Safari не поддерживает нативный input type date или есть конфликт JavaScript событий",
              "var_4": "Chrome автоматически полифиллит датапикер через Blink engine, Safari требует библиотеку",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Как спроектировать стратегию кроссбраузерного тестирования для мобильного банкинга, если Safari на iOS занимает 65% трафика, а ресурсы на тестирование ограничены?",
              "correct_answer": "Приоритизировать Safari iOS с полным покрытием, для остальных браузеров smoke-тесты критичных сценариев, автоматизация регрессии",
              "var_1": "Полное покрытие Safari iOS и Chrome Android, Edge тестировать раз в квартал перед релизами",
              "var_2": "Приоритизировать Safari iOS с полным покрытием, для остальных браузеров smoke-тесты критичных сценариев, автоматизация регрессии",
              "var_3": "Фокус на Chrome Desktop как эталоне, затем адаптация тестов для Safari iOS через эмуляторы",
              "var_4": "Равномерное распределение ресурсов между всеми браузерами с пропорциональным покрытием согласно статистике трафика",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Тестирование мобильных приложений на различных платформах: iOS vs Android, особенности UI/UX и нативных функций",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой инструмент используется для тестирования мобильного приложения банка одновременно на iOS и Android устройствах?",
              "correct_answer": "BrowserStack или Sauce Labs для кроссплатформенного тестирования",
              "var_1": "Selenium WebDriver с мобильными браузерами",
              "var_2": "BrowserStack или Sauce Labs для кроссплатформенного тестирования",
              "var_3": "Xcode Simulator и Android Studio Emulator локально",
              "var_4": "Postman для API тестирования мобильных приложений",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В чем основное различие в тестировании push-уведомлений для банковского приложения на iOS и Android?",
              "correct_answer": "iOS требует сертификаты APNs, Android использует FCM с токенами",
              "var_1": "iOS требует сертификаты APNs, Android использует FCM с токенами",
              "var_2": "iOS использует GCM, Android требует сертификаты P12 для уведомлений",
              "var_3": "iOS поддерживает только silent push, Android требует обязательный звук",
              "var_4": "Android требует Apple Developer аккаунт, iOS использует Firebase SDK",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Как спроектировать стратегию регрессионного тестирования биометрической аутентификации для банковского приложения, учитывая различия Face ID и BiometricPrompt API?",
              "correct_answer": "Создать отдельные test suites с mock-данными для каждой платформы, учитывая различия в обработке ошибок и UI flow",
              "var_1": "Тестировать биометрию через UI automation framework с эмуляцией отпечатков и лиц на реальных устройствах без mock-слоя",
              "var_2": "Создать отдельные test suites с mock-данными для каждой платформы, учитывая различия в обработке ошибок и UI flow",
              "var_3": "Применять snapshot testing для биометрических экранов с последующей визуальной регрессией через image comparison инструменты",
              "var_4": "Использовать единую test suite с условной логикой по платформе, проверяя только успешные сценарии биометрической аутентификации",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Стратегии тестирования десктопных приложений на Windows, macOS и Linux: совместимость, производительность и специфичные баги",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой инструмент используется для эмуляции различных разрешений экрана при тестировании десктопного банковского приложения на Windows?",
              "correct_answer": "Настройки масштабирования дисплея или виртуальные машины с разными разрешениями",
              "var_1": "Настройки масштабирования дисплея или виртуальные машины с разными разрешениями",
              "var_2": "Selenium Grid с настройкой window.resizeTo() в тестовых скриптах",
              "var_3": "Chrome DevTools с режимом адаптивного дизайна для десктопных разрешений",
              "var_4": "Docker контейнеры с параметрами DISPLAY для разных экранов",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В чем основное различие между тестированием обработки путей к файлам в банковском приложении на Windows и Linux при импорте выписок?",
              "correct_answer": "Windows использует обратный слэш и буквы дисков, Linux — прямой слэш",
              "var_1": "Linux регистрозависим для путей, Windows автоматически нормализует регистр символов",
              "var_2": "Windows требует UTF-16 кодировку путей, Linux работает с UTF-8 по умолчанию",
              "var_3": "Windows ограничивает длину пути 260 символами, Linux поддерживает до 4096 символов",
              "var_4": "Windows использует обратный слэш и буквы дисков, Linux — прямой слэш",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "Как спроектировать стратегию регрессионного тестирования производительности для клиента интернет-банкинга на трех ОС, учитывая ограниченные ресурсы команды из 4 QA?",
              "correct_answer": "Приоритизация критичных сценариев, автоматизация smoke-тестов производительности, ротационное глубокое тестирование по ОС",
              "var_1": "Полное покрытие функциональности на каждой ОС с метриками производительности каждый релиз",
              "var_2": "Фокус на тестировании Windows как основной платформы, выборочные проверки macOS и Linux",
              "var_3": "Приоритизация критичных сценариев, автоматизация smoke-тестов производительности, ротационное глубокое тестирование по ОС",
              "var_4": "Создание единой матрицы тестов с параллельным запуском на всех ОС виртуальными машинами",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Управление тестовой средой и приоритизация платформ: матрица совместимости, эмуляторы vs реальные устройства, оптимизация покрытия",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое матрица совместимости в контексте кроссплатформенного тестирования мобильного банкинга?",
              "correct_answer": "Таблица комбинаций ОС, версий, устройств и браузеров для тестирования.",
              "var_1": "Документ с требованиями по совместимости приложения с устройствами.",
              "var_2": "Таблица комбинаций ОС, версий, устройств и браузеров для тестирования.",
              "var_3": "Список багов и дефектов, найденных на разных платформах.",
              "var_4": "График зависимостей между модулями приложения и внешними сервисами.",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В каких случаях для тестирования мобильного приложения банка следует использовать реальные устройства вместо эмуляторов?",
              "correct_answer": "При тестировании камеры, NFC-платежей, биометрии, производительности и специфичных багов устройств.",
              "var_1": "Для проверки совместимости различных версий ОС, разрешений экранов и локализации.",
              "var_2": "При тестировании камеры, NFC-платежей, биометрии, производительности и специфичных багов устройств.",
              "var_3": "Когда необходимо протестировать интеграцию с API, обработку ошибок и бизнес-логику.",
              "var_4": "При тестировании UI-элементов, навигации, валидации форм и базового функционала приложения.",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "Как спроектировать оптимальную стратегию приоритизации платформ для тестирования банковского веб-приложения с ограниченным бюджетом на устройства?",
              "correct_answer": "Анализ аналитики пользователей, выделение топ-5 комбинаций, риск-ориентированный подход, smoke на эмуляторах, критичные сценарии на реальных устройствах.",
              "var_1": "Анализ аналитики пользователей, выделение топ-5 комбинаций, риск-ориентированный подход, smoke на эмуляторах, критичные сценарии на реальных устройствах.",
              "var_2": "Приоритизация по доле рынка операционных систем, параллельное тестирование всех платформ, использование Docker-контейнеров для изоляции окружений.",
              "var_3": "Тестирование на всех популярных браузерах и ОС через облачные фермы устройств, полное regression-покрытие на каждой платформе.",
              "var_4": "Создание матрицы совместимости по последним версиям браузеров, автоматизация всех тестов, выполнение на эмуляторах для экономии бюджета.",
              "correct_position": 1
            }
          ]
        }
      ]
    },
    {
      "competency": "Знание регламентов обработки заявок (SLA, приоритизация)",
      "type": "DAILY",
      "importance": 70,
      "themes": [
        {
          "theme": "Определение и классификация приоритетов дефектов (Critical, High, Medium, Low)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой приоритет дефекта следует установить, если в мобильном приложении банка не работает функция входа по биометрии, но доступен вход по паролю?",
              "correct_answer": "High, так как затронута основная функция, но есть обходной путь",
              "var_1": "Critical, поскольку нарушена безопасность и удобство аутентификации пользователей",
              "var_2": "High, так как затронута основная функция, но есть обходной путь",
              "var_3": "Medium, так как биометрия является дополнительной опцией удобства",
              "var_4": "Low, потому что основная функциональность входа полностью доступна",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В чем разница между приоритетом Critical и High для дефекта в системе обработки платежей телеком-оператора, если транзакции проходят с задержкой 10 минут?",
              "correct_answer": "High — система работает с деградацией, Critical — если полная блокировка бизнес-процесса",
              "var_1": "Critical — задержка более 5 минут, High — задержка до 5 минут",
              "var_2": "High — влияет на SLA оператора, Critical — влияет на репутацию компании",
              "var_3": "High — система работает с деградацией, Critical — если полная блокировка бизнес-процесса",
              "var_4": "Critical определяется по количеству затронутых пользователей, High — по времени задержки",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Продакт требует понизить приоритет дефекта с Critical до High для падения интеграции с НБРК, аргументируя малым процентом пользователей. Какие риски и как обоснуете отказ?",
              "correct_answer": "Регуляторные риски, штрафы НБРК, репутационные потери. Критичность определяется не количеством пользователей, а бизнес-импактом",
              "var_1": "Понизить до High с добавлением тега regulatory. Критичность зависит от SLA договора с НБРК",
              "var_2": "Согласиться при наличииworkaround. Приоритет определяется частотой воспроизведения и количеством affected users",
              "var_3": "Регуляторные риски, штрафы НБРК, репутационные потери. Критичность определяется не количеством пользователей, а бизнес-импактом",
              "var_4": "Эскалировать в техподдержку НБРК для уточнения критичности. Документировать решение продакта в Jira",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Расчет и мониторинг SLA для обработки багов и запросов на тестирование",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое SLA в контексте обработки багов в банковской системе?",
              "correct_answer": "Соглашение об уровне сервиса, определяющее максимальное время обработки дефектов",
              "var_1": "Система логирования активности пользователей и аналитики производительности тестирования",
              "var_2": "Стандарт лицензирования программного обеспечения для банковских приложений",
              "var_3": "Соглашение об уровне сервиса, определяющее максимальное время обработки дефектов",
              "var_4": "Соглашение о структуре логов и архивировании данных",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "Какой приоритет баг-репорта следует установить, если в мобильном банкинге не работает перевод между своими счетами для 30% пользователей Android?",
              "correct_answer": "Critical/P1, так как затронута критическая функция с массовым влиянием",
              "var_1": "Critical/P1, так как затронута критическая функция с массовым влиянием",
              "var_2": "High/P2, так как проблема воспроизводится не у всех пользователей",
              "var_3": "Critical/P1, но можно отложить до следующего релиза с workaround",
              "var_4": "Major/P2, требуется анализ логов и воспроизведение на тестовом окружении",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Команда системно нарушает SLA по критическим багам из-за длительного согласования фиксов со службой безопасности банка. Как оптимизировать процесс?",
              "correct_answer": "Внедрить параллельное согласование, создать pre-approved список изменений и отдельный SLA для ИБ",
              "var_1": "Внедрить параллельное согласование, создать pre-approved список изменений и отдельный SLA для ИБ",
              "var_2": "Передать ответственность за согласование с ИБ разработчикам для ускорения процесса релизов",
              "var_3": "Создать отдельную очередь багов безопасности и выделить dedicated тестировщика для ИБ",
              "var_4": "Увеличить SLA для критических багов с учетом времени согласования службы безопасности",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Эскалация заявок: критерии, процессы и коммуникация со стейкхолдерами",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое эскалация заявки в контексте обработки инцидентов?",
              "correct_answer": "Передача заявки на более высокий уровень поддержки или руководству",
              "var_1": "Увеличение приоритета заявки в рамках текущей линии поддержки",
              "var_2": "Передача заявки на более высокий уровень поддержки или руководству",
              "var_3": "Создание связанной задачи для разработчиков через систему трекинга",
              "var_4": "Автоматическое перенаправление заявки в другой отдел по категории",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В каких случаях необходимо использовать функциональную эскалацию вместо иерархической при обработке критического инцидента в банковской системе?",
              "correct_answer": "Когда текущей команде не хватает технической экспертизы для решения",
              "var_1": "Когда текущей команде не хватает технической экспертизы для решения",
              "var_2": "Когда инцидент влияет на критические бизнес-процессы клиентов банка",
              "var_3": "Когда SLA по времени реакции на инцидент уже нарушен",
              "var_4": "Когда руководитель команды поддержки недоступен для принятия решения",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Клиент банка жалуется, что критичная P1 заявка не эскалирована после истечения SLA. При проверке выяснилось, что автоэскалация сработала, но стейкхолдеры не среагировали. Как предотвратить подобные ситуации?",
              "correct_answer": "Внедрить многоуровневое оповещение с резервными контактами и дежурными ротациями",
              "var_1": "Передать ответственность за мониторинг эскалаций команде поддержки первой линии",
              "var_2": "Настроить автоматическое повышение приоритета заявки до P0 при просрочке",
              "var_3": "Внедрить многоуровневое оповещение с резервными контактами и дежурными ротациями",
              "var_4": "Увеличить время SLA для P1 заявок с учетом реального времени реакции",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Управление backlog дефектов и оптимизация процесса их обработки",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое backlog дефектов в контексте работы QA-инженера?",
              "correct_answer": "Список всех зарегистрированных, но еще не исправленных дефектов в проекте.",
              "var_1": "Список критических дефектов, требующих немедленного исправления в продакшене.",
              "var_2": "Список всех зарегистрированных, но еще не исправленных дефектов в проекте.",
              "var_3": "Очередь дефектов, ожидающих назначения приоритета и распределения разработчикам.",
              "var_4": "Архив закрытых дефектов за предыдущий спринт или релиз проекта.",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "Какие критерии следует использовать для приоритизации дефектов в backlog мобильного банкинга при подготовке к релизу?",
              "correct_answer": "Критичность для бизнеса, влияние на пользователей, частота воспроизведения и сложность исправления.",
              "var_1": "Дата создания дефекта, назначенный исполнитель, время на исправление и оценка QA.",
              "var_2": "Критичность для бизнеса, влияние на пользователей, частота воспроизведения и сложность исправления.",
              "var_3": "Мнение Product Owner, загруженность разработчиков, доступность тестовых данных и время регрессии.",
              "var_4": "Severity по ISTQB, количество затронутых экранов, версия сборки и окружение тестирования.",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "В телеком-проекте backlog дефектов достиг 500+ записей, команда не успевает обрабатывать новые. Какие действия предпримете для оптимизации?",
              "correct_answer": "Провести grooming сессию, закрыть устаревшие дефекты, ввести жесткие критерии приемки, автоматизировать регрессию, пересмотреть SLA.",
              "var_1": "Провести grooming сессию, закрыть устаревшие дефекты, ввести жесткие критерии приемки, автоматизировать регрессию, пересмотреть SLA.",
              "var_2": "Перевести все дефекты в статус отложено, сосредоточиться только на критических багах текущего спринта.",
              "var_3": "Увеличить команду тестировщиков, внедрить дополнительные инструменты багтрекинга, проводить ежедневные встречи по дефектам.",
              "var_4": "Делегировать обработку дефектов разработчикам, внедрить систему штрафов за просроченные баги, усилить контроль менеджмента.",
              "correct_position": 1
            }
          ]
        }
      ]
    },
    {
      "competency": "Навыки SQL",
      "type": "DAILY",
      "importance": 60,
      "themes": [
        {
          "theme": "Основы SQL: SELECT-запросы, фильтрация данных (WHERE, LIKE, IN) и сортировка результатов",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой оператор SQL используется для выборки клиентов банка, чьи ИИН начинаются с '950'?",
              "correct_answer": "LIKE '950%' в условии WHERE",
              "var_1": "STARTS WITH '950' в условии WHERE",
              "var_2": "IN ('950') в условии WHERE",
              "var_3": "LIKE '%950' в условии WHERE",
              "var_4": "LIKE '950%' в условии WHERE",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием IN и множественных OR при фильтрации транзакций по 15 филиалам банка?",
              "correct_answer": "IN повышает читаемость кода и производительность, упрощает поддержку запроса",
              "var_1": "OR обеспечивает более гибкую индексацию и быстрее обрабатывает запросы",
              "var_2": "IN создает отдельные подзапросы для каждого филиала, ускоряя выборку",
              "var_3": "IN повышает читаемость кода и производительность, упрощает поддержку запроса",
              "var_4": "OR позволяет использовать составные индексы для оптимизации фильтрации данных",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "Почему запрос выборки абонентов с LIKE '%87012%' на таблице из 5 млн записей выполняется 40 секунд?",
              "correct_answer": "LIKE с ведущим wildcard не использует индекс, требуется full table scan",
              "var_1": "Индекс на номере телефона фрагментирован и требует rebuild через REINDEX",
              "var_2": "VARCHAR колонка требует преобразования типов перед сравнением со строковым литералом",
              "var_3": "LIKE с ведущим wildcard не использует индекс, требуется full table scan",
              "var_4": "Оператор LIKE выполняет последовательное сканирование вместо bitmap index scan",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Объединение таблиц: INNER JOIN, LEFT JOIN, RIGHT JOIN и работа с внешними ключами",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип JOIN вернёт все записи из таблицы clients, даже если у клиента нет связанных записей в таблице accounts?",
              "correct_answer": "LEFT JOIN возвращает все записи из левой таблицы.",
              "var_1": "FULL OUTER JOIN возвращает записи только с совпадениями.",
              "var_2": "LEFT JOIN возвращает все записи из левой таблицы.",
              "var_3": "RIGHT JOIN возвращает все записи из первой таблицы.",
              "var_4": "INNER JOIN возвращает все записи из обеих таблиц.",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В базе банка таблица transactions ссылается на clients через client_id. При тестировании вы обнаружили транзакции с client_id = NULL. Какой JOIN покажет эти записи при объединении с таблицей clients?",
              "correct_answer": "LEFT JOIN от transactions к clients покажет записи с NULL.",
              "var_1": "RIGHT JOIN от transactions к clients покажет записи с NULL.",
              "var_2": "INNER JOIN от transactions к clients покажет записи с NULL.",
              "var_3": "LEFT JOIN от transactions к clients покажет записи с NULL.",
              "var_4": "FULL OUTER JOIN обязателен для отображения NULL в client_id.",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "После миграции данных в банковской системе обнаружено, что LEFT JOIN между payments и customers возвращает дубликаты платежей. При этом INNER JOIN работает корректно. Какая наиболее вероятная причина проблемы?",
              "correct_answer": "Отсутствие или нарушение внешнего ключа создало дубли в customers.",
              "var_1": "Индексы на внешних ключах payments устарели после переноса данных.",
              "var_2": "Отсутствие или нарушение внешнего ключа создало дубли в customers.",
              "var_3": "LEFT JOIN автоматически создает декартово произведение при миграции данных.",
              "var_4": "Различная сортировка результатов LEFT JOIN приводит к визуальным дублям.",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Агрегатные функции и группировка: COUNT, SUM, AVG, GROUP BY, HAVING для анализа тестовых данных",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая агрегатная функция SQL используется для подсчета количества транзакций клиента в таблице payments?",
              "correct_answer": "COUNT() подсчитывает количество строк или непустых значений.",
              "var_1": "SUM() суммирует количество записей в таблице payments.",
              "var_2": "TOTAL() подсчитывает общее число транзакций клиента.",
              "var_3": "AVG() вычисляет среднее количество строк по группам.",
              "var_4": "COUNT() подсчитывает количество строк или непустых значений.",
              "correct_position": 4
            },
            {
              "level": "Middle",
              "question": "В таблице test_results нужно найти типы дефектов с более чем 10 случаями. Почему нельзя использовать WHERE для фильтрации по COUNT(*)?",
              "correct_answer": "WHERE фильтрует до группировки, нужен HAVING для фильтрации агрегатных результатов.",
              "var_1": "WHERE применяется к строкам таблицы, COUNT(*) работает с результирующим набором.",
              "var_2": "WHERE фильтрует до группировки, нужен HAVING для фильтрации агрегатных результатов.",
              "var_3": "Агрегатные функции выполняются после WHERE, требуется дополнительный подзапрос для фильтрации.",
              "var_4": "COUNT(*) требует предварительной индексации, WHERE работает только с индексированными полями.",
              "correct_position": 2
            },
            {
              "level": "Senior",
              "question": "При анализе транзакций мобильного банкинга запрос с GROUP BY по user_id выполняется 45 секунд на 10 млн записей. Какие проблемы производительности проверите первыми?",
              "correct_answer": "Отсутствие индекса на user_id, неэффективные агрегации, отсутствие партиционирования таблицы.",
              "var_1": "Отсутствие индекса на user_id, неэффективные агрегации, отсутствие партиционирования таблицы.",
              "var_2": "Неоптимальные настройки буферного пула, высокая конкуренция за ресурсы CPU, недостаток IOPS дисковой подсистемы.",
              "var_3": "Отсутствие кластерных индексов, блокировки таблиц, фрагментация дискового пространства базы данных.",
              "var_4": "Недостаточная оперативная память сервера, низкая пропускная способность сети, устаревшая версия СУБД.",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "Подзапросы и операторы модификации данных: вложенные SELECT, INSERT, UPDATE, DELETE для подготовки тестовых наборов",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой оператор SQL используется для удаления тестовых транзакций клиентов с балансом меньше 100 тенге из таблицы accounts на основе данных из таблицы transactions?",
              "correct_answer": "DELETE FROM accounts WHERE account_id IN (SELECT account_id FROM transactions)",
              "var_1": "DELETE FROM accounts WHERE account_id IN (SELECT account_id FROM transactions)",
              "var_2": "DELETE FROM transactions WHERE account_id IN (SELECT account_id FROM accounts WHERE balance < 100)",
              "var_3": "REMOVE FROM accounts WHERE balance < 100 AND account_id IN (SELECT account_id FROM transactions)",
              "var_4": "UPDATE accounts SET deleted = true WHERE account_id IN (SELECT account_id FROM transactions WHERE balance < 100)",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием подзапроса в WHERE и JOIN при обновлении статусов абонентов телеком-оператора, которые не совершали звонков более 90 дней?",
              "correct_answer": "Подзапрос читает данные дважды, JOIN эффективнее для больших объемов данных",
              "var_1": "Подзапрос блокирует строки на запись, JOIN выполняет разделяемую блокировку",
              "var_2": "JOIN требует создания временной таблицы, подзапрос работает с индексами",
              "var_3": "WHERE с подзапросом использует план выполнения с MERGE операцией",
              "var_4": "Подзапрос читает данные дважды, JOIN эффективнее для больших объемов данных",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "Почему массовый INSERT с подзапросом для копирования 5 миллионов тестовых транзакций банка вызывает блокировку таблицы и как это исправить?",
              "correct_answer": "Используйте батчинг с LIMIT или INSERT с временной таблицей и коммитами",
              "var_1": "Используйте параллельный INSERT с PARTITION BY и увеличьте innodb_buffer_pool_size",
              "var_2": "Примените NOLOCK hint в INSERT и отключите автокоммит для ускорения операции",
              "var_3": "Используйте батчинг с LIMIT или INSERT с временной таблицей и коммитами",
              "var_4": "Увеличьте параметр lock_wait_timeout и используйте READ UNCOMMITTED изоляцию транзакций",
              "correct_position": 3
            }
          ]
        }
      ]
    },
    {
      "competency": "Навыки работы с СУБД",
      "type": "DAILY",
      "importance": 60,
      "themes": [
        {
          "theme": "Основы SQL: SELECT-запросы, фильтрация и сортировка данных",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой оператор SQL используется для фильтрации записей клиентов банка по определенному условию в SELECT-запросе?",
              "correct_answer": "WHERE для фильтрации строк по условию",
              "var_1": "FILTER для отбора записей по критериям",
              "var_2": "WHERE для фильтрации строк по условию",
              "var_3": "SELECT с условием в теле запроса",
              "var_4": "HAVING для фильтрации строк таблицы",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В чем разница между ORDER BY и WHERE при выборке транзакций клиентов телеком-оператора, и в каком порядке они должны применяться?",
              "correct_answer": "WHERE фильтрует данные, ORDER BY сортирует результат; WHERE идет перед ORDER BY",
              "var_1": "ORDER BY фильтрует записи, WHERE сортирует данные; порядок применения определяется оптимизатором запросов",
              "var_2": "ORDER BY индексирует данные, WHERE выбирает строки; ORDER BY должен идти перед WHERE для оптимизации",
              "var_3": "WHERE и ORDER BY выполняются параллельно движком БД; ORDER BY применяется к исходной таблице",
              "var_4": "WHERE фильтрует данные, ORDER BY сортирует результат; WHERE идет перед ORDER BY",
              "correct_position": 4
            },
            {
              "level": "Senior",
              "question": "При тестировании выборки 5 миллионов банковских транзакций запрос с WHERE amount > 100000 ORDER BY transaction_date выполняется 45 секунд. Какие проблемы производительности могут быть и как диагностировать?",
              "correct_answer": "Отсутствие индексов на amount и transaction_date; проверить через EXPLAIN план выполнения запроса",
              "var_1": "Отсутствие индексов на amount и transaction_date; проверить через EXPLAIN план выполнения запроса",
              "var_2": "Недостаточная память сервера; увеличить RAM и настроить параметры кеширования в конфигурации СУБД",
              "var_3": "Фрагментация таблицы после массовых UPDATE; выполнить VACUUM FULL и REINDEX для оптимизации хранения",
              "var_4": "Блокировки таблиц от параллельных транзакций; проверить через SELECT * FROM pg_locks активные блокировки",
              "correct_position": 1
            }
          ]
        },
        {
          "theme": "JOIN-операции и работа с связанными таблицами",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип JOIN вернёт все записи из таблицы clients, даже если нет совпадений в таблице accounts?",
              "correct_answer": "LEFT JOIN или LEFT OUTER JOIN",
              "var_1": "INNER JOIN с условием IS NULL",
              "var_2": "RIGHT JOIN или RIGHT OUTER JOIN",
              "var_3": "LEFT JOIN или LEFT OUTER JOIN",
              "var_4": "FULL JOIN с фильтрацией по clients",
              "correct_position": 3
            },
            {
              "level": "Middle",
              "question": "В банковской системе нужно получить клиентов без активных счетов. Какой JOIN использовать с условием WHERE accounts.id IS NULL?",
              "correct_answer": "LEFT JOIN с проверкой на NULL в правой таблице",
              "var_1": "RIGHT JOIN с условием accounts.status = 'inactive'",
              "var_2": "INNER JOIN с фильтрацией по статусу счета",
              "var_3": "LEFT JOIN с проверкой на NULL в правой таблице",
              "var_4": "FULL OUTER JOIN с проверкой NULL в обеих таблицах",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "При тестировании выборки транзакций клиентов запрос с INNER JOIN работает 8 секунд на 2 млн записей. Какие первые шаги troubleshooting?",
              "correct_answer": "Проверить индексы на ключах JOIN и EXPLAIN план запроса",
              "var_1": "Заменить INNER JOIN на LEFT JOIN для оптимизации выборки",
              "var_2": "Увеличить memory_limit и connection pool размер сервера БД",
              "var_3": "Проверить индексы на ключах JOIN и EXPLAIN план запроса",
              "var_4": "Добавить LIMIT в запрос и проверить работу pagination",
              "correct_position": 3
            }
          ]
        },
        {
          "theme": "Агрегатные функции и группировка данных (GROUP BY, HAVING)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая агрегатная функция используется для подсчета количества транзакций клиента в таблице payments?",
              "correct_answer": "COUNT() для подсчета строк или транзакций",
              "var_1": "COUNT() для подсчета строк или транзакций",
              "var_2": "SUM() для суммирования всех транзакций клиента",
              "var_3": "GROUP BY для группировки транзакций по клиенту",
              "var_4": "DISTINCT для получения уникальных записей транзакций",
              "correct_position": 1
            },
            {
              "level": "Middle",
              "question": "В чем разница между WHERE и HAVING при анализе суммы платежей клиентов банка по филиалам?",
              "correct_answer": "WHERE фильтрует строки до группировки, HAVING фильтрует результаты после агрегации",
              "var_1": "WHERE фильтрует строки до группировки, HAVING фильтрует результаты после агрегации",
              "var_2": "WHERE применяется к агрегатным функциям, HAVING к обычным столбцам таблиц",
              "var_3": "WHERE используется для внешних запросов, HAVING для подзапросов с GROUP BY",
              "var_4": "HAVING фильтрует данные перед JOIN, WHERE после объединения таблиц филиалов",
              "correct_position": 1
            },
            {
              "level": "Senior",
              "question": "Почему запрос с GROUP BY по client_id работает медленно на 50 млн записей транзакций, если индекс существует?",
              "correct_answer": "Возможно отсутствие составного индекса или высокая кардинальность требует партиционирования таблицы",
              "var_1": "Планировщик использует Nested Loop вместо Hash Aggregate из-за статистики",
              "var_2": "Возможно отсутствие составного индекса или высокая кардинальность требует партиционирования таблицы",
              "var_3": "Индекс на client_id фрагментирован и требует перестроения через REBUILD INDEX",
              "var_4": "Отсутствует индекс на поля в SELECT и нужно добавить COVERING INDEX",
              "correct_position": 2
            }
          ]
        },
        {
          "theme": "Подзапросы, представления (VIEW) и оптимизация запросов для тестирования",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое VIEW в реляционных базах данных и для чего он используется?",
              "correct_answer": "Виртуальная таблица, сохраняющая результат SELECT-запроса для переиспользования.",
              "var_1": "Материализованная копия данных с автоматической синхронизацией изменений.",
              "var_2": "Виртуальная таблица, сохраняющая результат SELECT-запроса для переиспользования.",
              "var_3": "Временная таблица, хранящая промежуточные результаты JOIN-операций.",
              "var_4": "Физическая таблица с индексами для ускорения выборки данных.",
              "correct_position": 2
            },
            {
              "level": "Middle",
              "question": "В каком случае использовать подзапрос в WHERE вместо JOIN при тестировании выборки активных клиентов банка с транзакциями за последний месяц?",
              "correct_answer": "Когда нужна проверка существования записей без дублирования строк основной таблицы.",
              "var_1": "Когда необходимо получить все поля из связанной таблицы транзакций",
              "var_2": "Когда требуется объединить данные из нескольких таблиц с агрегацией",
              "var_3": "Когда нужна проверка существования записей без дублирования строк основной таблицы.",
              "var_4": "Для повышения производительности при больших объемах данных в обеих таблицах",
              "correct_position": 3
            },
            {
              "level": "Senior",
              "question": "При тестировании отчета по абонентам телеком-оператора VIEW с тремя JOIN работает 45 секунд на 5 млн записей. Какие первые три действия для диагностики проблемы производительности?",
              "correct_answer": "EXPLAIN план запроса, проверка индексов на JOIN-полях, анализ статистики таблиц.",
              "var_1": "Оптимизация через хинты FORCE INDEX, увеличение buffer pool, репликация таблиц.",
              "var_2": "EXPLAIN план запроса, проверка индексов на JOIN-полях, анализ статистики таблиц.",
              "var_3": "Перенос VIEW в материализованное представление, денормализация таблиц, кэширование результатов.",
              "var_4": "Добавление DISTINCT, использование UNION вместо JOIN, партиционирование VIEW.",
              "correct_position": 2
            }
          ]
        }
      ]
    }
  ]
}