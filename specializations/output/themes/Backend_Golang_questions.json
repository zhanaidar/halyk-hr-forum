{
  "profile": "Backend разработчик",
  "specialization": "Golang Backend",
  "file_name": "Backend_Golang",
  "competencies": [
    {
      "competency": "Навыки работы с Golang",
      "type": "CORE",
      "importance": 90,
      "themes": [
        {
          "theme": "Concurrency и goroutines: channels, sync-пакет, race conditions, контекст выполнения",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая функция из пакета sync используется для ожидания завершения нескольких goroutines перед продолжением выполнения программы?",
              "correct_answer": "sync.WaitGroup с методами Add, Done и Wait"
            },
            {
              "level": "Middle",
              "question": "В микросервисе обработки платежей банка нужно отменить все дочерние операции при таймауте основного запроса. Какой механизм context использовать и почему?",
              "correct_answer": "context.WithTimeout — автоматически отменяет операции по истечении времени"
            },
            {
              "level": "Senior",
              "question": "При масштабировании сервиса транзакций телеком-оператора с 10K до 100K RPS обнаружили деградацию из-за contention на sync.Mutex в кэше сессий. Как оптимизировать архитектуру?",
              "correct_answer": "Использовать sync.Map или шардированный кэш с множеством мьютексов"
            }
          ]
        },
        {
          "theme": "Работа с интерфейсами, структурами и методами: композиция, встраивание, type assertions",
          "questions": [
            {
              "level": "Junior",
              "question": "Как правильно встроить структуру Account в структуру BankCustomer для получения доступа к её полям и методам?",
              "correct_answer": "Указать имя типа без имени поля: type BankCustomer struct { Account }"
            },
            {
              "level": "Middle",
              "question": "В микросервисе платежей используется интерфейс PaymentProcessor с методом Process(). Нужно добавить валидацию для карточных платежей, сохранив существующую логику. Какой подход композиции лучше применить?",
              "correct_answer": "Создать структуру-обёртку с полем типа PaymentProcessor, реализующую дополнительную логику перед вызовом"
            },
            {
              "level": "Senior",
              "question": "В системе обработки транзакций банка интерфейс interface{} приходит из очереди. Почему type assertion к конкретному типу без проверки второго возвращаемого значения может вызвать критическую проблему в production?",
              "correct_answer": "Вызовет panic при несовпадении типа, что приведёт к падению сервиса обработки транзакций"
            }
          ]
        },
        {
          "theme": "Управление памятью и производительность: garbage collector, профилирование, оптимизация аллокаций",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой инструмент стандартной библиотеки Go используется для профилирования использования памяти приложением?",
              "correct_answer": "pprof из пакета net/http/pprof или runtime/pprof"
            },
            {
              "level": "Middle",
              "question": "В высоконагруженном банковском API обработки платежей наблюдаются частые паузы GC. Какие параметры GOGC стоит настроить и почему?",
              "correct_answer": "Увеличить GOGC выше 100 для уменьшения частоты сборок мусора за счет большего потребления памяти"
            },
            {
              "level": "Senior",
              "question": "В микросервисе обработки транзакций телеком-оператора профилирование показало 80% аллокаций на создание временных []byte при парсинге JSON. Как оптимизировать без изменения API?",
              "correct_answer": "Использовать sync.Pool для переиспользования буферов и jsoniter с предаллоцированными структурами"
            }
          ]
        },
        {
          "theme": "Обработка ошибок и panic recovery: error wrapping, custom errors, defer, best practices",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая функция из пакета fmt используется для создания ошибки с форматированным сообщением в Go?",
              "correct_answer": "fmt.Errorf"
            },
            {
              "level": "Middle",
              "question": "В банковском микросервисе обработки платежей нужно сохранить стек ошибок при передаче между слоями. Какой подход из стандартной библиотеки Go 1.13+ обеспечит это без внешних зависимостей?",
              "correct_answer": "fmt.Errorf с %w для wrapping и errors.Unwrap"
            },
            {
              "level": "Senior",
              "question": "В высоконагруженном процессинге транзакций телеком-оператора goroutine падает с panic в defer. Почему recover() в внешнем defer не перехватит этот panic и как правильно спроектировать многоуровневую защиту?",
              "correct_answer": "Panic в defer создает новый panic, прерывая цепочку. Нужен recover в каждом defer или wrapper-функция с отдельным defer-recover."
            }
          ]
        }
      ]
    },
    {
      "competency": "Concurrency (горутины, каналы, синхронизация)",
      "type": "CORE",
      "importance": 85,
      "themes": [
        {
          "theme": "Goroutines: жизненный цикл, планировщик (scheduler), runtime и управление ресурсами",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой синтаксис используется для запуска новой горутины в Go?",
              "correct_answer": "Ключевое слово go перед вызовом функции"
            },
            {
              "level": "Middle",
              "question": "В банковском сервисе обработки платежей запускается 10000 горутин одновременно. Как ограничить их количество для контроля потребления памяти?",
              "correct_answer": "Использовать worker pool с буферизованным каналом или семафор"
            },
            {
              "level": "Senior",
              "question": "Телеком-оператор обрабатывает 500k запросов/сек. Наблюдается высокая задержка GC и частые preemption горутин. Какие параметры runtime оптимизировать и почему?",
              "correct_answer": "GOMAXPROCS для CPU, GOGC для частоты GC, использовать sync.Pool для переиспользования объектов"
            }
          ]
        },
        {
          "theme": "Channels: типы каналов, буферизация, паттерны использования и deadlock prevention",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой синтаксис используется для создания буферизованного канала в Go с емкостью 10 элементов?",
              "correct_answer": "ch := make(chan int, 10)"
            },
            {
              "level": "Middle",
              "question": "В системе обработки банковских транзакций нужно распределить 1000 запросов между 5 воркерами. Какой размер буфера канала оптимален для предотвращения блокировки отправителя при кратковременных задержках воркеров?",
              "correct_answer": "Буфер размером 50-200, равный числу запросов на воркера"
            },
            {
              "level": "Senior",
              "question": "В микросервисе обработки платежей телеком-оператора возникает deadlock при использовании двух каналов для координации между горутинами сбора метрик и отправки в Kafka. Какие три архитектурных паттерна предотвратят эту проблему?",
              "correct_answer": "Select с default, timeout context, разделение на однонаправленные каналы"
            }
          ]
        },
        {
          "theme": "Синхронизация: sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Once и их применение",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой примитив синхронизации используется для ожидания завершения нескольких горутин перед продолжением выполнения программы?",
              "correct_answer": "sync.WaitGroup с методами Add, Done и Wait"
            },
            {
              "level": "Middle",
              "question": "В системе обработки банковских транзакций необходимо кешировать курсы валют. Чтений в 100 раз больше записей. Какой примитив синхронизации оптимален и почему?",
              "correct_answer": "sync.RWMutex, позволяет множественные одновременные чтения при блокировке записи"
            },
            {
              "level": "Senior",
              "question": "При инициализации подключения к платежному шлюзу используется sync.Once, но после сетевой ошибки переподключение не происходит. Как архитектурно решить проблему повторной инициализации при сохранении потокобезопасности?",
              "correct_answer": "Использовать sync.Mutex с атомарной проверкой состояния или паттерн circuit breaker"
            }
          ]
        },
        {
          "theme": "Продвинутые паттерны конкурентности: worker pools, context cancellation, select statement и race conditions",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой оператор в Go позволяет горутине ожидать данные из нескольких каналов одновременно?",
              "correct_answer": "Оператор select"
            },
            {
              "level": "Middle",
              "question": "В банковской системе обработки платежей нужно остановить все воркеры при завершении работы. Какой механизм Context использовать для graceful shutdown?",
              "correct_answer": "context.WithCancel с вызовом cancel() и ожидание через sync.WaitGroup"
            },
            {
              "level": "Senior",
              "question": "В телеком-биллинге worker pool обрабатывает 10000 транзакций/сек, но появились race conditions при обновлении счетчиков. Как оптимально решить без деградации производительности?",
              "correct_answer": "Использовать atomic операции для счетчиков или sharding с отдельными каналами"
            }
          ]
        }
      ]
    },
    {
      "competency": "Event-Driven Architecture",
      "type": "DAILY",
      "importance": 70,
      "themes": [
        {
          "theme": "Message Brokers и паттерны обмена сообщениями (RabbitMQ, Kafka, NATS)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой паттерн обмена сообщениями в RabbitMQ используется для отправки одного сообщения нескольким подписчикам одновременно?",
              "correct_answer": "Fanout exchange или паттерн Publish-Subscribe"
            },
            {
              "level": "Middle",
              "question": "В банковской системе нужно обрабатывать транзакции клиентов с гарантией порядка для каждого клиента. Kafka или RabbitMQ и какой механизм использовать?",
              "correct_answer": "Kafka сpartitioning по clientID для сохранения порядка внутри partition"
            },
            {
              "level": "Senior",
              "question": "В телеком-системе после деплоя consumers начали массово отваливаться с ошибками timeout при чтении из Kafka. Продюсеры работают нормально. Какие три основные причины проверить?",
              "correct_answer": "Размер batch fetch, session.timeout и медленная обработка сообщений блокирующая poll"
            }
          ]
        },
        {
          "theme": "Event Sourcing и CQRS паттерны в Golang приложениях",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое Event Sourcing и как он отличается от традиционного хранения состояния в базе данных?",
              "correct_answer": "Хранение всех изменений как последовательности событий, а не текущего состояния."
            },
            {
              "level": "Middle",
              "question": "В банковском приложении на Golang нужно реализовать историю транзакций клиента. Когда стоит использовать CQRS вместо обычного CRUD подхода?",
              "correct_answer": "Когда требования к чтению и записи различаются, нужна масштабируемость чтения."
            },
            {
              "level": "Senior",
              "question": "В телеком-системе обработки платежей на Golang с Event Sourcing возникла проблема: восстановление агрегата из 50000 событий занимает 3 секунды. Как оптимизировать производительность?",
              "correct_answer": "Внедрить снапшоты агрегата каждые N событий, восстанавливать от последнего снапшота."
            }
          ]
        },
        {
          "theme": "Обработка ошибок и retry механизмы в асинхронных системах",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой Go-пакет используется для реализации экспоненциальной задержки между retry попытками при обработке сообщений из Kafka?",
              "correct_answer": "time.Sleep с увеличивающимся интервалом или backoff библиотека"
            },
            {
              "level": "Middle",
              "question": "В event-driven системе банка сообщение обработки платежа падает с temporary error. Когда использовать Dead Letter Queue вместо бесконечных retry?",
              "correct_answer": "После исчерпания лимита retry попыток или при превышении TTL сообщения"
            },
            {
              "level": "Senior",
              "question": "В телеком системе обработки биллинга events теряются при перезапуске сервиса. Consumer offset коммитится после обработки, но есть дубликаты при retry. Как спроектировать идемпотентность?",
              "correct_answer": "Использовать idempotency key в базе с уникальным индексом и транзакционный outbox pattern"
            }
          ]
        },
        {
          "theme": "Saga паттерн и распределенные транзакции в микросервисной архитектуре",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое Saga паттерн в микросервисной архитектуре?",
              "correct_answer": "Последовательность локальных транзакций с компенсирующими действиями при ошибках"
            },
            {
              "level": "Middle",
              "question": "Какой тип Saga использовать для процесса открытия банковского счета с проверкой в 5 сервисах: choreography или orchestration?",
              "correct_answer": "Orchestration, так как требуется централизованный контроль сложного бизнес-процесса"
            },
            {
              "level": "Senior",
              "question": "В телеком-системе Saga зависла на 3-м шаге из 7. Компенсирующие транзакции отработали частично. Как диагностировать и восстановить консистентность?",
              "correct_answer": "Проверить состояние в saga state store, откатить частичные компенсации, повторно запустить компенсации идемпотентно"
            }
          ]
        }
      ]
    },
    {
      "competency": "Проектирование REST/gRPC API",
      "type": "CORE",
      "importance": 85,
      "themes": [
        {
          "theme": "Принципы REST API: HTTP методы, коды ответов, versioning и resource naming",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой HTTP метод следует использовать для получения списка банковских счетов клиента в REST API?",
              "correct_answer": "GET метод для безопасного чтения данных"
            },
            {
              "level": "Middle",
              "question": "Какой код ответа вернуть, когда клиент банка пытается перевести деньги со счета с недостаточным балансом?",
              "correct_answer": "422 Unprocessable Entity с описанием бизнес-ошибки"
            },
            {
              "level": "Senior",
              "question": "Как спроектировать versioning REST API для банковского мобильного приложения, чтобы обеспечить обратную совместимость при изменении структуры данных платежей?",
              "correct_answer": "URL versioning с семантическим версионированием и поддержкой минимум двух версий одновременно"
            }
          ]
        },
        {
          "theme": "Проектирование gRPC сервисов: Protocol Buffers, streaming, error handling и interceptors",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип данных в Protocol Buffers используется для передачи денежных сумм в тенге с точностью до тиын?",
              "correct_answer": "double или создать custom message с int64 для тиын"
            },
            {
              "level": "Middle",
              "question": "Какой тип streaming в gRPC выбрать для реализации real-time уведомлений о транзакциях клиента банка: unary, server streaming или bidirectional streaming?",
              "correct_answer": "Server streaming для отправки последовательности уведомлений клиенту"
            },
            {
              "level": "Senior",
              "question": "Как спроектировать interceptor для логирования чувствительных данных ИИН и номера карты в gRPC сервисе банка с учетом требований ПДн?",
              "correct_answer": "Unary/stream interceptor с маскированием через reflection proto-полей, помеченных custom option sensitive"
            }
          ]
        },
        {
          "theme": "Архитектура API: идемпотентность, pagination, filtering, rate limiting и authentication",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое идемпотентность REST API и какие HTTP методы являются идемпотентными?",
              "correct_answer": "Повторный запрос даёт тот же результат. GET, PUT, DELETE идемпотентны."
            },
            {
              "level": "Middle",
              "question": "Какой подход pagination выбрать для API выписок по счетам клиента банка: offset-based или cursor-based, и почему?",
              "correct_answer": "Cursor-based, чтобы избежать пропусков транзакций при добавлении новых записей."
            },
            {
              "level": "Senior",
              "question": "Как спроектировать идемпотентность для POST запроса создания платежа в банковском API, учитывая сетевые таймауты и retry логику клиентов?",
              "correct_answer": "Idempotency-Key в заголовке, хранение ключа с результатом в Redis/БД, проверка дубликатов."
            }
          ]
        },
        {
          "theme": "Оптимизация и масштабирование: connection pooling, batch operations, caching strategies и load balancing",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое connection pooling в контексте работы с базой данных PostgreSQL в Golang?",
              "correct_answer": "Переиспользование установленных соединений с БД вместо создания новых для каждого запроса."
            },
            {
              "level": "Middle",
              "question": "В банковской системе с пиковой нагрузкой 5000 RPS какую стратегию кеширования выбрать для справочника курсов валют, обновляемого раз в минуту?",
              "correct_answer": "Cache-aside с TTL 60 секунд и preemptive refresh за 5 секунд до истечения."
            },
            {
              "level": "Senior",
              "question": "Как спроектировать batch operations для gRPC API массовых платежей в телеком-биллинге, чтобы избежать head-of-line blocking при частичных сбоях?",
              "correct_answer": "Использовать server-side streaming с независимой обработкой каждой операции и partial success response с детализацией ошибок."
            }
          ]
        }
      ]
    },
    {
      "competency": "Тестирование и работа с legacy кодом",
      "type": "DAILY",
      "importance": 65,
      "themes": [
        {
          "theme": "Написание unit и integration тестов для Golang приложений с использованием testify и gomock",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой метод testify/assert используется для проверки, что функция вернула ошибку nil?",
              "correct_answer": "assert.NoError или require.NoError"
            },
            {
              "level": "Middle",
              "question": "В чем разница между использованием testify/assert и testify/require при тестировании критичных операций с базой данных банковских транзакций?",
              "correct_answer": "require немедленно прерывает тест при ошибке, предотвращая некорректные данные"
            },
            {
              "level": "Senior",
              "question": "Вы добавляете unit-тесты в legacy код обработки платежей, где 10 функций напрямую вызывают database/sql. Какой подход минимизирует рефакторинг для внедрения gomock?",
              "correct_answer": "Создать интерфейс поверх существующих SQL-вызовов и использовать adapter pattern"
            }
          ]
        },
        {
          "theme": "Рефакторинг legacy кода: работа с технических долгом и стратегии постепенной модернизации",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое технический долг в контексте legacy кода?",
              "correct_answer": "Накопленные проблемы кода, требующие рефакторинга для поддержки и развития."
            },
            {
              "level": "Middle",
              "question": "Какую стратегию выбрать для рефакторинга монолитного банковского сервиса на Go с высоким покрытием тестами: Big Bang Rewrite или Strangler Fig Pattern?",
              "correct_answer": "Strangler Fig Pattern для постепенной миграции без остановки критичных операций."
            },
            {
              "level": "Senior",
              "question": "В legacy платежном сервисе телеком-оператора обнаружены race conditions при миграции на новую архитектуру. Как безопасно выявить и устранить проблему в продакшене?",
              "correct_answer": "Включить race detector в staging, добавить sync.Mutex, использовать feature flags для постепенного роллаута."
            }
          ]
        },
        {
          "theme": "Покрытие legacy кода тестами: техники характеризационного тестирования и работа с зависимостями",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое характеризационное тестирование (characterization testing) при работе с legacy кодом?",
              "correct_answer": "Тесты, документирующие текущее поведение системы без изменения кода."
            },
            {
              "level": "Middle",
              "question": "В legacy системе банка метод ProcessPayment() зависит от внешнего API платежного шлюза. Какой паттерн использовать для изоляции этой зависимости при написании тестов?",
              "correct_answer": "Dependency Injection с использованием интерфейсов для мокирования шлюза."
            },
            {
              "level": "Senior",
              "question": "В legacy монолите телеком оператора метод CalculateBilling() содержит 800 строк с прямыми обращениями к БД, файловой системе и глобальным переменным. Опишите пошаговую стратегию покрытия его тестами без рефакторинга логики.",
              "correct_answer": "Обернуть в Facade, извлечь зависимости через Seam-точки, написать интеграционные тесты с testcontainers, затем постепенно изолировать внешние вызовы."
            }
          ]
        },
        {
          "theme": "Использование table-driven tests и benchmark тестов для оптимизации производительности legacy систем",
          "questions": [
            {
              "level": "Junior",
              "question": "Какая структура данных используется для определения тестовых случаев в table-driven тестах в Go?",
              "correct_answer": "Слайс структур с полями input и expected"
            },
            {
              "level": "Middle",
              "question": "В legacy системе обработки платежей банка некоторые тесты падают с разными результатами при параллельном запуске через t.Parallel(). Какая наиболее вероятная причина?",
              "correct_answer": "Разделяемое состояние между тестами или race condition в коде"
            },
            {
              "level": "Senior",
              "question": "При оптимизации legacy модуля тарификации телеком-оператора бенчмарк показывает 15000 B/op с 250 аллокациями. Какие два первых шага для диагностики проблемы?",
              "correct_answer": "Запустить pprof с alloc_space и проверить escape analysis компилятора"
            }
          ]
        }
      ]
    }
  ]
}