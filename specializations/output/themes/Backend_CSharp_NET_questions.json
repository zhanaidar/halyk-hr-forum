{
  "profile": "Backend разработчик",
  "specialization": "C# / .NET",
  "file_name": "Backend_CSharp_NET",
  "competencies": [
    {
      "competency": "Знание языка программирования C#",
      "type": "CORE",
      "importance": 90,
      "themes": [
        {
          "theme": "Типы данных, операторы и управляющие конструкции в C#",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой тип данных в C# используется для хранения суммы банковского перевода до 79,228,162,514,264,337,593,543,950,335 с точностью до копеек?",
              "correct_answer": "decimal"
            },
            {
              "level": "Middle",
              "question": "В системе обработки платежей нужно проверить статус транзакции и вернуть результат одним выражением. Какой оператор позволит избежать NullReferenceException при проверке transaction?.Status == 'completed'?",
              "correct_answer": "Null-conditional оператор ?. возвращает null если объект null"
            },
            {
              "level": "Senior",
              "question": "В высоконагруженном телеком-биллинге обрабатываются миллионы записей звонков. Почему использование struct вместо class для CallRecord с полями DateTime, int, decimal может ухудшить производительность при boxing/unboxing в коллекциях?",
              "correct_answer": "Struct копируется по значению, boxing в List<object> создает heap-аллокации и давление на GC"
            }
          ]
        },
        {
          "theme": "Объектно-ориентированное программирование: классы, интерфейсы, наследование и полиморфизм",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой модификатор доступа в C# делает член класса доступным только внутри этого класса и производных классов?",
              "correct_answer": "protected"
            },
            {
              "level": "Middle",
              "question": "В банковской системе нужно обрабатывать платежи разных типов (карточные, SWIFT, внутренние переводы). Какой принцип ООП позволит обрабатывать их единообразно через общий интерфейс IPayment?",
              "correct_answer": "Полиморфизм через реализацию интерфейса"
            },
            {
              "level": "Senior",
              "question": "В телеком-биллинговой системе класс Customer содержит List<Invoice> и List<Contract>. При сериализации через API возникают циклические ссылки. Как спроектировать архитектуру, чтобы избежать этой проблемы без использования атрибутов игнорирования?",
              "correct_answer": "Использовать DTO паттерн с маппингом и разделением доменных моделей от контрактов API"
            }
          ]
        },
        {
          "theme": "Обобщения (Generics), делегаты, события и LINQ",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой синтаксис используется для объявления generic-метода, который принимает список любого типа и возвращает первый элемент?",
              "correct_answer": "public T GetFirst<T>(List<T> items) { return items[0]; }"
            },
            {
              "level": "Middle",
              "question": "В системе обработки банковских транзакций нужно фильтровать платежи по разным критериям. Какой подход эффективнее: несколько методов с конкретными условиями или делегаты Func/Predicate в LINQ?",
              "correct_answer": "Делегаты Func/Predicate с LINQ обеспечивают гибкость и переиспользуемость кода."
            },
            {
              "level": "Senior",
              "question": "При проектировании event-driven системы уведомлений для телеком-оператора с миллионами подписчиков, какие проблемы возникают при использовании стандартных событий C# и как их решить?",
              "correct_answer": "Утечки памяти при незакрытых подписках, блокировка потоков. Решение: weak references, async events, event aggregator pattern."
            }
          ]
        },
        {
          "theme": "Асинхронное программирование: async/await, Task и многопоточность",
          "questions": [
            {
              "level": "Junior",
              "question": "Что возвращает async метод, который выполняет асинхронную операцию и не возвращает результат?",
              "correct_answer": "Task"
            },
            {
              "level": "Middle",
              "question": "В чем разница между Task.Run() и Task.Factory.StartNew() при обработке запросов в банковском API?",
              "correct_answer": "Task.Run использует TaskScheduler.Default, StartNew позволяет настроить планировщик и параметры выполнения."
            },
            {
              "level": "Senior",
              "question": "Почему в высоконагруженном платежном шлюзе не следует использовать Task.Result или .Wait() для ожидания асинхронных операций?",
              "correct_answer": "Блокируют поток, вызывают deadlock при SynchronizationContext, снижают пропускную способность и масштабируемость системы."
            }
          ]
        }
      ]
    },
    {
      "competency": "Знание платформы .NET Core / .NET Framework",
      "type": "CORE",
      "importance": 90,
      "themes": [
        {
          "theme": "Архитектура и жизненный цикл .NET приложений: CLR, JIT-компиляция, сборка мусора и управление памятью",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое CLR в платформе .NET и какую основную функцию он выполняет?",
              "correct_answer": "Common Language Runtime — среда выполнения, управляющая исполнением .NET кода"
            },
            {
              "level": "Middle",
              "question": "В чем разница между Server GC и Workstation GC, и когда следует использовать Server GC для высоконагруженного банковского API?",
              "correct_answer": "Server GC использует отдельные потоки для каждого ядра, оптимален для высокопроизводительных серверных приложений"
            },
            {
              "level": "Senior",
              "question": "Почему в процессинговом сервисе транзакций с требованием низкой latency следует использовать Span<T> вместо byte[] массивов, и как это влияет на работу GC?",
              "correct_answer": "Span<T> выделяется в стеке, избегает аллокаций в куче и давления на GC, снижая паузы сборки мусора"
            }
          ]
        },
        {
          "theme": "Dependency Injection и встроенный IoC-контейнер: регистрация сервисов, время жизни (Singleton, Scoped, Transient)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой метод используется для регистрации сервиса с временем жизни Transient в ASP.NET Core?",
              "correct_answer": "services.AddTransient<TService, TImplementation>()"
            },
            {
              "level": "Middle",
              "question": "Какое время жизни сервиса выбрать для DbContext при разработке банковского API с высокой нагрузкой?",
              "correct_answer": "Scoped, чтобы использовать один контекст на HTTP-запрос"
            },
            {
              "level": "Senior",
              "question": "Почему регистрация Scoped-сервиса как зависимости в Singleton может привести к Captive Dependency и как это предотвратить?",
              "correct_answer": "Singleton живет весь lifetime приложения и удерживает Scoped, используйте IServiceScopeFactory для создания scope вручную"
            }
          ]
        },
        {
          "theme": "Middleware pipeline и обработка HTTP-запросов в ASP.NET Core: порядок выполнения, создание кастомных middleware",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой метод используется для регистрации middleware в ASP.NET Core в методе Configure класса Startup?",
              "correct_answer": "app.Use, app.UseMiddleware или app.Run"
            },
            {
              "level": "Middle",
              "question": "В чем разница между app.Use() и app.Run() при регистрации middleware в pipeline ASP.NET Core?",
              "correct_answer": "app.Use вызывает следующий middleware через next(), app.Run завершает pipeline"
            },
            {
              "level": "Senior",
              "question": "Какие проблемы возникнут при добавлении app.UseRouting() после app.UseAuthorization() в middleware pipeline банковского API, и как это повлияет на атрибуты [Authorize]?",
              "correct_answer": "Authorization выполнится до роутинга, endpoint будет null, авторизация всегда будет падать"
            }
          ]
        },
        {
          "theme": "Асинхронное программирование: async/await, Task Parallel Library, ConfigureAwait и управление контекстом синхронизации",
          "questions": [
            {
              "level": "Junior",
              "question": "Какое ключевое слово используется для пометки метода как асинхронного в C#?",
              "correct_answer": "async"
            },
            {
              "level": "Middle",
              "question": "В чем разница между ConfigureAwait(false) и ConfigureAwait(true) при обработке запросов к банковской БД?",
              "correct_answer": "ConfigureAwait(false) не возвращает выполнение в исходный контекст синхронизации"
            },
            {
              "level": "Senior",
              "question": "Почему в высоконагруженном API платежного шлюза возникает thread pool starvation при блокирующих вызовах Task.Result вместо await?",
              "correct_answer": "Task.Result блокирует поток, исчерпывая пул потоков и препятствуя обработке новых запросов"
            }
          ]
        }
      ]
    },
    {
      "competency": "Работа с базами данных (MS SQL, PostgreSQL, Oracle)",
      "type": "CORE",
      "importance": 85,
      "themes": [
        {
          "theme": "Проектирование схем баз данных: нормализация, индексы, ограничения целостности",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое первичный ключ (Primary Key) в таблице базы данных?",
              "correct_answer": "Уникальный идентификатор записи, не допускающий NULL значения."
            },
            {
              "level": "Middle",
              "question": "В таблице транзакций банка 50 млн записей. Запросы по customer_id и transaction_date медленные. Какой тип индекса оптимален для частых диапазонных запросов по дате с фильтром по клиенту?",
              "correct_answer": "Составной кластерный индекс на (customer_id, transaction_date)."
            },
            {
              "level": "Senior",
              "question": "Проектируете схему хранения тарифных планов телеком-оператора с историей изменений и валидацией периодов действия. Как обеспечить целостность данных при наложении периодов для одного клиента без race conditions?",
              "correct_answer": "Использовать temporal таблицы с CHECK constraint на период и SERIALIZABLE isolation level для проверки пересечений."
            }
          ]
        },
        {
          "theme": "Оптимизация SQL-запросов и анализ планов выполнения (Execution Plans)",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой оператор в MS SQL Server используется для просмотра плана выполнения запроса без его фактического выполнения?",
              "correct_answer": "SET SHOWPLAN_ALL ON или SET STATISTICS PROFILE ON"
            },
            {
              "level": "Middle",
              "question": "В плане выполнения запроса к таблице транзакций банка вы видите Table Scan вместо Index Seek. Какие два основных способа оптимизации этого запроса?",
              "correct_answer": "Создать подходящий индекс на столбцы из WHERE и обновить статистику таблицы"
            },
            {
              "level": "Senior",
              "question": "В телеком-системе запрос JOIN трех таблиц (абоненты 50M записей, тарифы, платежи) показывает Hash Match вместо Nested Loops. Почему оптимизатор выбрал Hash Match и в каких случаях это оптимально?",
              "correct_answer": "Hash Match эффективен для больших объемов данных без подходящих индексов, когда стоимость сортировки ниже множественных Index Seek операций"
            }
          ]
        },
        {
          "theme": "Транзакции, уровни изоляции и управление конкурентным доступом",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой уровень изоляции транзакций в SQL Server используется по умолчанию?",
              "correct_answer": "Read Committed"
            },
            {
              "level": "Middle",
              "question": "В банковской системе при одновременном списании с одного счета возникают дублирующие транзакции. Какой уровень изоляции в PostgreSQL предотвратит это без блокировок на чтение?",
              "correct_answer": "Serializable с retry logic на serialization failure"
            },
            {
              "level": "Senior",
              "question": "В высоконагруженном биллинге телеком-оператора на MS SQL возникают deadlock'и при UPDATE балансов абонентов. Как спроектировать архитектуру доступа к данным для минимизации блокировок при сохранении консистентности?",
              "correct_answer": "Упорядоченный доступ к записям по ID, применение UPDLOCK hint, разделение операций на read-модификация-write с оптимистичной блокировкой через rowversion"
            }
          ]
        },
        {
          "theme": "Работа с базами данных в .NET: ADO.NET, Dapper, Entity Framework Core",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой класс ADO.NET используется для выполнения SQL-команд и возврата результата в виде потока данных?",
              "correct_answer": "SqlDataReader для чтения данных в режиме forward-only."
            },
            {
              "level": "Middle",
              "question": "В чем ключевое различие между подходами Database First и Code First в Entity Framework Core при интеграции с legacy-системами банка?",
              "correct_answer": "Database First генерирует модели из существующей БД, Code First создает схему из кода."
            },
            {
              "level": "Senior",
              "question": "Как спроектировать оптимальную стратегию работы с большими объемами транзакций (50+ млн записей) при использовании EF Core и обеспечить производительность запросов аналитики?",
              "correct_answer": "AsNoTracking для чтения, SqlBulkCopy для вставок, индексированные представления, разделение на горячие и холодные данные."
            }
          ]
        }
      ]
    },
    {
      "competency": "Проектирование и архитектура",
      "type": "CORE",
      "importance": 80,
      "themes": [
        {
          "theme": "SOLID принципы и паттерны проектирования в .NET приложениях",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой SOLID принцип нарушается, если класс BankAccount одновременно работает с балансом, логирует операции и отправляет SMS-уведомления?",
              "correct_answer": "Single Responsibility Principle - класс имеет множественные причины для изменения"
            },
            {
              "level": "Middle",
              "question": "В банковском приложении нужно поддержать несколько способов аутентификации (SMS, биометрия, токен). Какой паттерн проектирования лучше использовать и почему?",
              "correct_answer": "Strategy pattern - позволяет инкапсулировать алгоритмы и переключаться между ними динамически"
            },
            {
              "level": "Senior",
              "question": "Вы проектируете систему обработки платежей для телеком-оператора с интеграцией 15+ платёжных провайдеров. Как спроектировать архитектуру, чтобы соблюсти Open/Closed Principle и минимизировать изменения при добавлении новых провайдеров?",
              "correct_answer": "Использовать абстракцию IPaymentProvider с фабрикой или стратегией, регистрировать провайдеры через DI контейнер"
            }
          ]
        },
        {
          "theme": "Архитектурные стили и подходы: монолит, микросервисы, Clean Architecture, DDD",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое монолитная архитектура в контексте разработки банковского приложения на .NET?",
              "correct_answer": "Единое приложение, где все модули развернуты и работают в одном процессе."
            },
            {
              "level": "Middle",
              "question": "Когда следует выбрать микросервисную архитектуру вместо монолита для системы мобильного оператора с 10 млн абонентов?",
              "correct_answer": "Когда нужно независимое масштабирование модулей, разные команды и частые релизы."
            },
            {
              "level": "Senior",
              "question": "Как спроектировать границы Bounded Context в DDD для core-banking системы с платежами, кредитами и депозитами, чтобы минимизировать связанность?",
              "correct_answer": "Выделить контексты по бизнес-доменам с собственными моделями, общаться через события или API."
            }
          ]
        },
        {
          "theme": "Проектирование слоев приложения и управление зависимостями (DI/IoC контейнеры)",
          "questions": [
            {
              "level": "Junior",
              "question": "Что такое Dependency Injection и какую проблему он решает в .NET приложениях?",
              "correct_answer": "Паттерн внедрения зависимостей через конструктор, устраняет жесткую связанность классов."
            },
            {
              "level": "Middle",
              "question": "В банковском API нужно регистрировать сервис для работы с транзакциями. Когда использовать Scoped вместо Singleton lifetime?",
              "correct_answer": "Scoped для сервисов с состоянием на запрос, включая DbContext и транзакционную логику."
            },
            {
              "level": "Senior",
              "question": "Как спроектировать слоистую архитектуру для процессинга платежей, чтобы Domain слой не зависел от Infrastructure, но использовал репозитории?",
              "correct_answer": "Определить интерфейсы репозиториев в Domain, реализацию в Infrastructure, регистрировать через DI контейнер."
            }
          ]
        },
        {
          "theme": "Масштабируемость и производительность: кэширование, асинхронность, оптимизация баз данных",
          "questions": [
            {
              "level": "Junior",
              "question": "Какой встроенный интерфейс в .NET используется для реализации in-memory кэширования?",
              "correct_answer": "IMemoryCache из пространства имён Microsoft.Extensions.Caching.Memory"
            },
            {
              "level": "Middle",
              "question": "В банковской системе нужно кэшировать справочники валют и курсы обмена. Какую стратегию инвалидации выбрать для каждого типа данных?",
              "correct_answer": "Справочники - абсолютное время истечения, курсы - скользящее время с коротким TTL"
            },
            {
              "level": "Senior",
              "question": "Как спроектировать кэширование для высоконагруженного API телеком-оператора с 10000 RPS, учитывая персонализированные данные абонентов и требование eventual consistency до 5 секунд?",
              "correct_answer": "Двухуровневое кэширование: Redis с шардингом по абоненту плюс локальный IMemoryCache с pub/sub инвалидацией"
            }
          ]
        }
      ]
    }
  ]
}