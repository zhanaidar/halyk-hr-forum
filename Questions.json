{
  "profiles": [
    {
    "profile": "Backend разработчик",
    "specialization": "Java / Spring",
    "competencies": [
        {
        "competency_name": "Навыки Java [CORE 90%]",
        "topics": [
            {
            "topic_name": "Коллекции и структуры данных",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какой интерфейс в Java используется для хранения уникальных элементов?",
                "var_1": "List реализует проверку уникальности через метод contains() при добавлении",
                "var_2": "Set использует внутренний механизм для предотвращения добавления дубликатов",
                "var_3": "Map обеспечивает уникальность ключей через внутреннюю хеш-таблицу",
                "var_4": "Collection предоставляет базовый контракт для работы с уникальными данными",
                "correct_answer": 2
                },
                {
                "level": "Middle",
                "question_text": "Когда следует использовать LinkedHashMap вместо HashMap?",
                "var_1": "Когда требуется автоматическая сортировка элементов по ключу",
                "var_2": "Когда необходимо сохранение порядка вставки элементов",
                "var_3": "Когда важна потокобезопасная работа с коллекцией",
                "var_4": "Когда нужна оптимизация операций поиска по значению",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Почему ConcurrentHashMap не поддерживает null в качестве ключа или значения?",
                "var_1": "Это связано с особенностями работы алгоритма сегментации данных",
                "var_2": "Невозможно различить отсутствие значения от явного null без дополнительной синхронизации",
                "var_3": "Оптимизация производительности требует исключения обработки null значений",
                "var_4": "Предотвращение race condition при проверке наличия элемента в коллекции",
                "correct_answer": 2
                }
            ]
            },
            {
            "topic_name": "Многопоточность и concurrency",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Что произойдёт при повторном вызове start() у объекта Thread?",
                "var_1": "Поток продолжит выполнение с текущей точки в методе run()",
                "var_2": "Будет выброшено исключение IllegalThreadStateException",
                "var_3": "Поток будет перезапущен с начала метода run()",
                "var_4": "JVM создаст новый экземпляр потока автоматически",
                "correct_answer": 2
                },
                {
                "level": "Middle",
                "question_text": "В чём основное преимущество ReentrantLock перед synchronized блоком?",
                "var_1": "ReentrantLock обеспечивает более высокую производительность при низкой конкуренции",
                "var_2": "ReentrantLock поддерживает tryLock() с таймаутом и прерывание ожидания",
                "var_3": "ReentrantLock автоматически освобождается при завершении метода",
                "var_4": "ReentrantLock предотвращает deadlock через встроенную детекцию",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Какую проблему решает happens-before отношение в Java Memory Model?",
                "var_1": "Гарантирует атомарность составных операций при работе с общими переменными",
                "var_2": "Обеспечивает видимость изменений между потоками через упорядочивание операций",
                "var_3": "Предотвращает создание лишних копий объектов в thread-local памяти",
                "var_4": "Оптимизирует переключение контекста между потоками через prefetching",
                "correct_answer": 2
                }
            ]
            },
            {
            "topic_name": "Stream API и функциональное программирование",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какой метод Stream API используется для преобразования элементов?",
                "var_1": "map() применяет функцию к каждому элементу",
                "var_2": "filter() отбирает элементы по предикату",
                "var_3": "flatMap() разворачивает вложенные потоки",
                "var_4": "reduce() комбинирует элементы в результат",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "В чём разница между map() и flatMap() в Stream API?",
                "var_1": "map() поддерживает параллельную обработку элементов автоматически",
                "var_2": "flatMap() объединяет несколько потоков в один плоский поток",
                "var_3": "map() кеширует промежуточные результаты для оптимизации",
                "var_4": "flatMap() применяет функцию только к непустым элементам",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Почему findAny() может быть эффективнее findFirst() на параллельных стримах?",
                "var_1": "findAny() использует специальную хеш-структуру для быстрого поиска элемента",
                "var_2": "findAny() не требует сохранения порядка, возвращая результат без координации потоков",
                "var_3": "findAny() применяет предварительную фильтрацию для уменьшения количества проверок",
                "var_4": "findAny() кеширует последние найденные элементы для повторного использования",
                "correct_answer": 2
                }
            ]
            }
        ]
        },
        {
        "competency_name": "Навыки Spring Framework [CORE 90%]",
        "topics": [
            {
            "topic_name": "Dependency Injection и IoC контейнер",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какая аннотация используется для автоматического внедрения зависимости?",
                "var_1": "@Autowired указывает Spring на место инъекции",
                "var_2": "@Inject работает аналогично для внедрения",
                "var_3": "@Resource связывает бин по имени ресурса",
                "var_4": "@Qualifier уточняет конкретный бин для внедрения",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "Когда следует использовать @Qualifier при внедрении зависимости?",
                "var_1": "Когда нужно отложить инициализацию бина до первого обращения",
                "var_2": "Когда в контексте несколько бинов одного типа",
                "var_3": "Когда требуется изменить scope бина динамически",
                "var_4": "Когда необходимо внедрить Optional зависимость",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Как Spring обрабатывает циклические зависимости при конструкторной инъекции?",
                "var_1": "Создаёт proxy объекты для разрыва цикла зависимостей",
                "var_2": "Не может разрешить и выбрасывает BeanCurrentlyInCreationException",
                "var_3": "Использует lazy initialization для одного из бинов",
                "var_4": "Переключается на field injection для проблемных бинов",
                "correct_answer": 2
                }
            ]
            },
            {
            "topic_name": "Spring Boot автоконфигурация",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какая аннотация включает механизм автоконфигурации в Spring Boot?",
                "var_1": "@SpringBootApplication комбинирует несколько аннотаций включая автоконфигурацию",
                "var_2": "@EnableAutoConfiguration активирует автоматическую настройку компонентов",
                "var_3": "@ComponentScan запускает сканирование и регистрацию бинов",
                "var_4": "@Configuration определяет класс как источник bean definitions",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "Как исключить конкретный класс автоконфигурации из загрузки?",
                "var_1": "Создать собственную конфигурацию с аналогичными бинами",
                "var_2": "Указать класс в параметре exclude аннотации @SpringBootApplication",
                "var_3": "Добавить свойство в application.properties для отключения",
                "var_4": "Использовать @ConditionalOnMissingBean в custom конфигурации",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Почему @ConditionalOnMissingBean может не сработать для пользовательского бина?",
                "var_1": "Пользовательские бины имеют приоритет @Primary по умолчанию",
                "var_2": "Условие проверяется только в рамках текущего application context",
                "var_3": "Condition кеширует результат при первой проверке",
                "var_4": "User configurations обрабатываются до auto-configurations",
                "correct_answer": 4
                }
            ]
            },
            {
            "topic_name": "Spring Data JPA",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какой интерфейс нужно расширить для создания JPA репозитория?",
                "var_1": "JpaRepository предоставляет методы для работы с сущностями",
                "var_2": "CrudRepository определяет базовые CRUD операции",
                "var_3": "PagingAndSortingRepository добавляет пагинацию к CRUD",
                "var_4": "Repository служит маркерным интерфейсом для репозиториев",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "В чём разница между getOne() и findById() в JPA репозитории?",
                "var_1": "getOne() загружает сущность немедленно с eager стратегией",
                "var_2": "getOne() возвращает ленивый прокси, findById() загружает сразу",
                "var_3": "findById() кеширует результат в первом уровне кеша",
                "var_4": "getOne() использует JPQL запрос, findById() Criteria API",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Какие проблемы создаёт FetchType.EAGER для связей @OneToMany?",
                "var_1": "JPA материализует все данные в память перед маппингом",
                "var_2": "Создаётся отдельная транзакция для каждой коллекции",
                "var_3": "Возникает N+1 проблема и декартово произведение при JOIN",
                "var_4": "Блокировка базы данных на время загрузки всех связей",
                "correct_answer": 3
                }
            ]
            }
        ]
        },
        {
        "competency_name": "Навыки проектирования REST API [CORE 85%]",
        "topics": [
            {
            "topic_name": "HTTP методы и статус-коды",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какой HTTP метод используется для создания нового ресурса?",
                "var_1": "POST отправляет данные для создания ресурса",
                "var_2": "PUT размещает ресурс по указанному URI",
                "var_3": "PATCH модифицирует часть существующего ресурса",
                "var_4": "GET получает представление ресурса с сервера",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "В чём разница между статус-кодами 401 и 403?",
                "var_1": "401 означает отсутствие credentials, 403 недостаточно прав",
                "var_2": "401 для публичных API, 403 для internal endpoints",
                "var_3": "401 временная блокировка, 403 постоянный запрет",
                "var_4": "401 требует retry, 403 кеширует ответ на клиенте",
                "correct_answer": 1
                },
                {
                "level": "Senior",
                "question_text": "Почему PUT должен быть идемпотентным согласно HTTP спецификации?",
                "var_1": "Идемпотентность требуется для корректной работы HTTP кеширования",
                "var_2": "Клиенты могут безопасно повторять запрос при сетевых сбоях",
                "var_3": "Прокси-серверы автоматически retry идемпотентные операции",
                "var_4": "Идемпотентность упрощает реализацию distributed transactions",
                "correct_answer": 2
                }
            ]
            },
            {
            "topic_name": "Версионирование API",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какой подход использует версию в URL пути типа /api/v1/users?",
                "var_1": "URI path versioning включает версию в путь запроса",
                "var_2": "Query parameter versioning передаёт версию как параметр",
                "var_3": "Header versioning использует custom HTTP заголовок",
                "var_4": "Media type versioning включает версию в Content-Type",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "Когда следует создавать новую мажорную версию API?",
                "var_1": "При оптимизации производительности существующих endpoints",
                "var_2": "При внесении breaking changes в контракт API",
                "var_3": "При добавлении новых опциональных полей в response",
                "var_4": "При изменении внутренней реализации без изменения интерфейса",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Как организовать deprecation process при выводе старой версии API?",
                "var_1": "Объявить deprecation с sunset date, добавить warning headers, поддержать transition period",
                "var_2": "Автоматически redirect запросы на новую версию с data transformation",
                "var_3": "Немедленно отключить старую версию, вернуть 410 Gone всем клиентам",
                "var_4": "Поддерживать старую версию неограниченно для backward compatibility",
                "correct_answer": 1
                }
            ]
            },
            {
            "topic_name": "Pagination и filtering",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какие параметры используются для offset-based пагинации?",
                "var_1": "page и size определяют номер страницы и количество элементов",
                "var_2": "offset и limit задают смещение и размер выборки",
                "var_3": "start и end указывают границы диапазона данных",
                "var_4": "cursor и count управляют позицией и количеством",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "В чём преимущество cursor-based pagination перед offset-based?",
                "var_1": "Cursor требует меньше памяти на сервере при обработке",
                "var_2": "Cursor избегает пропуска записей при изменении данных",
                "var_3": "Cursor позволяет прямой доступ к произвольной странице",
                "var_4": "Cursor обеспечивает параллельную загрузку нескольких страниц",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Какая проблема возникает при deep pagination с большими offset значениями?",
                "var_1": "Невозможность применить сортировку и фильтрацию одновременно",
                "var_2": "Необходимость хранения состояния пагинации для каждого клиента",
                "var_3": "Получение устаревших данных из-за кеширования результатов",
                "var_4": "База данных сканирует все пропускаемые строки, деградируя производительность",
                "correct_answer": 4
                }
            ]
            }
        ]
        },
        {
        "competency_name": "Навыки Apache Kafka [DAILY 70%]",
        "topics": [
            {
            "topic_name": "Основы Kafka и топики",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Что такое партиция в контексте Kafka топика?",
                "var_1": "Партиция это реплика данных для обеспечения fault tolerance",
                "var_2": "Партиция это упорядоченный лог сообщений внутри топика",
                "var_3": "Партиция это группа consumers для parallel processing",
                "var_4": "Партиция это временный buffer для incoming messages",
                "correct_answer": 2
                },
                {
                "level": "Middle",
                "question_text": "Как Kafka гарантирует порядок доставки сообщений?",
                "var_1": "Порядок гарантируется на уровне топика для всех партиций",
                "var_2": "Порядок обеспечивается timestamps на каждом сообщении",
                "var_3": "Порядок гарантируется внутри одной партиции",
                "var_4": "Порядок поддерживается consumer group coordinator",
                "correct_answer": 3
                },
                {
                "level": "Senior",
                "question_text": "Как ключ сообщения влияет на распределение по партициям?",
                "var_1": "Ключ используется только для логической группировки в топике",
                "var_2": "Kafka балансирует сообщения равномерно независимо от ключа",
                "var_3": "Ключ определяет приоритет обработки в consumer group",
                "var_4": "Сообщения с одним ключом попадают в одну партицию через хеширование",
                "correct_answer": 4
                }
            ]
            },
            {
            "topic_name": "Consumer groups и offset management",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Что представляет собой consumer group в Kafka?",
                "var_1": "Набор consumers, распределяющих партиции для чтения",
                "var_2": "Группа брокеров, обрабатывающих один топик",
                "var_3": "Коллекция топиков, объединённых по назначению",
                "var_4": "Механизм репликации между Kafka кластерами",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "В чём разница между auto-commit и manual commit offset?",
                "var_1": "Manual commit использует batch операции для эффективности",
                "var_2": "Auto-commit сохраняет периодически, manual даёт полный контроль",
                "var_3": "Auto-commit обеспечивает exactly-once, manual at-least-once",
                "var_4": "Auto-commit фиксирует после обработки, manual перед чтением",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Какая проблема возникает с auto-commit при длительной обработке сообщения?",
                "var_1": "Consumer coordinator теряет информацию о progress обработки",
                "var_2": "Увеличивается нагрузка на брокеры из-за частых commit операций",
                "var_3": "Другие consumers блокируются на время длительной обработки",
                "var_4": "Offset коммитится до завершения, сообщение теряется при сбое",
                "correct_answer": 4
                }
            ]
            },
            {
            "topic_name": "Producers и гарантии доставки",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какой параметр producer определяет подтверждение записи?",
                "var_1": "acks определяет количество реплик для acknowledgment",
                "var_2": "retries задаёт число попыток при сбое отправки",
                "var_3": "batch.size контролирует размер группы сообщений",
                "var_4": "linger.ms управляет задержкой перед отправкой",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "В чём разница между настройками acks=1 и acks=all в producer?",
                "var_1": "acks=1 обеспечивает лучшую throughput, acks=all exactly-once",
                "var_2": "acks=1 ждёт leader, acks=all требует всех in-sync реплик",
                "var_3": "acks=all использует sync отправку, acks=1 async очередь",
                "var_4": "acks=1 для критичных данных, acks=all для метрик",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Как idempotent producer предотвращает дублирование при retry?",
                "var_1": "Consumer автоматически дедуплицирует сообщения при чтении",
                "var_2": "Producer кеширует отправленные сообщения локально",
                "var_3": "Distributed lock механизм предотвращает параллельную отправку",
                "var_4": "Broker присваивает sequence number и фильтрует дубликаты",
                "correct_answer": 4
                }
            ]
            }
        ]
        },
        {
        "competency_name": "Алгоритмы и структуры данных [DAILY 65%]",
        "topics": [
            {
            "topic_name": "Сложность алгоритмов",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какая временная сложность поиска элемента в несортированном массиве?",
                "var_1": "O(n) требуется проверка каждого элемента в худшем случае",
                "var_2": "O(1) благодаря прямой адресации по индексу",
                "var_3": "O(log n) при использовании binary search алгоритма",
                "var_4": "O(n log n) из-за предварительной сортировки",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "Почему HashMap обеспечивает O(1) для операций get/put в среднем случае?",
                "var_1": "Последние элементы кешируются в быстрой памяти",
                "var_2": "Хеш-функция вычисляет позицию напрямую в массиве",
                "var_3": "Внутри используется balanced binary search tree",
                "var_4": "Элементы поддерживаются в отсортированном порядке",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Когда HashMap деградирует до O(n) и как Java 8 решает проблему?",
                "var_1": "При плохой хеш-функции, Java использует rehashing второго уровня",
                "var_2": "При concurrent доступе, Java применяет lock striping механизм",
                "var_3": "При коллизиях в bucket, Java 8 конвертирует list в red-black tree",
                "var_4": "При высоком load factor, Java автоматически увеличивает capacity",
                "correct_answer": 3
                }
            ]
            },
            {
            "topic_name": "Деревья и графы",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какое ключевое свойство определяет Binary Search Tree?",
                "var_1": "Каждый узел содержит максимум два дочерних элемента",
                "var_2": "Левое поддерево содержит меньшие значения, правое большие",
                "var_3": "Дерево автоматически балансируется при операциях вставки",
                "var_4": "Все листовые узлы находятся на одинаковой глубине",
                "correct_answer": 2
                },
                {
                "level": "Middle",
                "question_text": "В чём преимущество Red-Black дерева перед обычным BST?",
                "var_1": "Red-Black tree эффективно хранит дубликаты через цветовую маркировку",
                "var_2": "Red-Black tree гарантирует O(log n) через балансировку при изменениях",
                "var_3": "Red-Black tree использует меньше памяти благодаря компактной структуре",
                "var_4": "Red-Black tree поддерживает быструю сериализацию в binary формат",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Как работает алгоритм Дейкстры и какое у него ограничение?",
                "var_1": "Использует dynamic programming для вычисления всех путей параллельно",
                "var_2": "Применяет recursive traversal с memoization для оптимизации памяти",
                "var_3": "Выполняет breadth-first search с весами, работает на любых графах",
                "var_4": "Использует greedy approach с priority queue, не работает с отрицательными весами",
                "correct_answer": 4
                }
            ]
            },
            {
            "topic_name": "Сортировки и поиск",
            "questions": [
                {
                "level": "Junior",
                "question_text": "Какая сортировка гарантирует O(n log n) в среднем случае?",
                "var_1": "Merge Sort использует divide-and-conquer подход",
                "var_2": "Bubble Sort оптимальна для больших массивов",
                "var_3": "Selection Sort находит minimum на каждой итерации",
                "var_4": "Insertion Sort вставляет элементы в sorted часть",
                "correct_answer": 1
                },
                {
                "level": "Middle",
                "question_text": "Почему Quick Sort предпочтительнее Merge Sort на практике?",
                "var_1": "Quick Sort показывает стабильные результаты на любых данных",
                "var_2": "Quick Sort использует O(1) памяти и лучше работает с кешем",
                "var_3": "Quick Sort это stable sort в отличие от Merge Sort",
                "var_4": "Quick Sort легче распараллелить на multi-core системах",
                "correct_answer": 2
                },
                {
                "level": "Senior",
                "question_text": "Как выбор pivot элемента влияет на производительность Quick Sort?",
                "var_1": "Выбор максимального элемента минимизирует глубину рекурсии",
                "var_2": "Выбор среднего элемента гарантирует равномерное разбиение массива",
                "var_3": "Выбор первого элемента обеспечивает стабильную O(n log n) сложность",
                "var_4": "Выбор random или median-of-three снижает риск O(n²) на sorted данных",
                "correct_answer": 4
                }
            ]
            }
        ]
        }
    ]
    }
  ]
}